"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.collectDependencies = exports.collectScripts = exports.collectTypeScript = void 0;
const module_1 = require("module");
const typescript_1 = __importDefault(require("typescript"));
const nodeAPIList = new Set(module_1.builtinModules);
exports.collectTypeScript = {
    extensions: ['.ts', '.tsx'],
    excludes: [
        // exclude tests
        '**/*.(spec|test).(js|jsx|ts|tsx)',
        '**/__*',
        // exclude public
        '**/public',
        '**/bin',
        // exclude javascript
        '**/*.js',
        '**/*.jsx',
    ],
    includes: ['**/*'],
};
exports.collectScripts = {
    extensions: ['.js', '.jsx', '.ts', '.tsx'],
    excludes: [
        // exclude tests
        '**/*.(spec|test).(js|jsx|ts|tsx)',
        '**/__*',
        // exclude public
        '**/public',
        '**/bin',
        // exclude public
        '**/public',
    ],
    includes: ['**/*'],
};
async function collectDependencies({ rootDir, internalPackages = new Map(), externalPackages, extensions = exports.collectTypeScript.extensions, excludes = exports.collectTypeScript.excludes, includes = exports.collectTypeScript.includes, compilerOptions = {}, selfNames = new Set(), fixImportPath, checkUndefinedPackage = 'error', }) {
    compilerOptions = {
        allowJs: extensions.some((ext) => /^.js/.test(ext)),
        ...compilerOptions,
        rootDir,
    };
    const host = typescript_1.default.createCompilerHost(compilerOptions);
    const files = host.readDirectory(rootDir, extensions, excludes, includes);
    const program = typescript_1.default.createProgram(files, compilerOptions, host);
    const importPaths = new Set();
    for (const file of files) {
        const sourceFile = program.getSourceFile(file);
        if (!sourceFile)
            continue;
        function search(node) {
            // import from '?'
            if (typescript_1.default.isImportDeclaration(node) &&
                typescript_1.default.isStringLiteralLike(node.moduleSpecifier) &&
                node.moduleSpecifier.text) {
                const importPath = node.moduleSpecifier.text;
                importPaths.add(typeof fixImportPath === 'function'
                    ? fixImportPath({
                        importPath,
                        filePath: file,
                    })
                    : importPath);
            }
            // import('?')
            else if (typescript_1.default.isCallExpression(node) &&
                node.expression.kind === typescript_1.default.SyntaxKind.ImportKeyword &&
                typescript_1.default.isStringLiteralLike(node.arguments[0])) {
                const importPath = node.arguments[0]
                    .text;
                importPaths.add(typeof fixImportPath === 'function'
                    ? fixImportPath({
                        importPath,
                        filePath: file,
                    })
                    : importPath);
            }
            // require.resolve('?')
            else if (typescript_1.default.isCallExpression(node) &&
                typescript_1.default.isPropertyAccessExpression(node.expression) &&
                typescript_1.default.isIdentifier(node.expression.expression) &&
                node.expression.expression.escapedText === 'require' &&
                node.expression.name.escapedText === 'resolve' &&
                typescript_1.default.isStringLiteralLike(node.arguments[0])) {
                const importPath = node.arguments[0]
                    .text;
                importPaths.add(typeof fixImportPath === 'function'
                    ? fixImportPath({
                        importPath,
                        filePath: file,
                    })
                    : importPath);
            }
            // require('?')
            else if (typescript_1.default.isCallExpression(node) &&
                typescript_1.default.isIdentifier(node.expression) &&
                node.expression.escapedText === 'require' &&
                typescript_1.default.isStringLiteralLike(node.arguments[0])) {
                const importPath = node.arguments[0]
                    .text;
                importPaths.add(typeof fixImportPath === 'function'
                    ? fixImportPath({
                        importPath,
                        filePath: file,
                    })
                    : importPath);
            }
            typescript_1.default.forEachChild(node, search);
        }
        search(sourceFile);
    }
    const imports = {};
    for (const importPath of importPaths) {
        const packageName = /^@/.test(importPath)
            ? importPath.split('/').slice(0, 2).join('/')
            : importPath.split('/')[0];
        if (!imports[packageName] &&
            !selfNames.has(packageName) &&
            !/^\./.test(packageName) &&
            !nodeAPIList.has(packageName)) {
            const internalPackage = internalPackages.get(packageName);
            if (internalPackage) {
                imports[packageName] = `^${internalPackage.version}`;
            }
            else if (externalPackages[packageName]) {
                imports[packageName] = externalPackages[packageName];
            }
            else if (checkUndefinedPackage === 'error') {
                throw new Error(`Undefined package "${packageName}" from "${importPath}"`);
            }
        }
    }
    return imports;
}
exports.collectDependencies = collectDependencies;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sbGVjdERlcGVuZGVuY2llcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9Ac3Nlbi9jb2xsZWN0LWRlcGVuZGVuY2llcy9jb2xsZWN0RGVwZW5kZW5jaWVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLG1DQUF3QztBQUV4Qyw0REFBNEI7QUFHNUIsTUFBTSxXQUFXLEdBQWdCLElBQUksR0FBRyxDQUFTLHVCQUFjLENBQUMsQ0FBQztBQUVwRCxRQUFBLGlCQUFpQixHQUkxQjtJQUNGLFVBQVUsRUFBRSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUM7SUFDM0IsUUFBUSxFQUFFO1FBQ1IsZ0JBQWdCO1FBQ2hCLGtDQUFrQztRQUNsQyxRQUFRO1FBRVIsaUJBQWlCO1FBQ2pCLFdBQVc7UUFDWCxRQUFRO1FBRVIscUJBQXFCO1FBQ3JCLFNBQVM7UUFDVCxVQUFVO0tBQ1g7SUFDRCxRQUFRLEVBQUUsQ0FBQyxNQUFNLENBQUM7Q0FDbkIsQ0FBQztBQUVXLFFBQUEsY0FBYyxHQUl2QjtJQUNGLFVBQVUsRUFBRSxDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQztJQUMxQyxRQUFRLEVBQUU7UUFDUixnQkFBZ0I7UUFDaEIsa0NBQWtDO1FBQ2xDLFFBQVE7UUFFUixpQkFBaUI7UUFDakIsV0FBVztRQUNYLFFBQVE7UUFFUixpQkFBaUI7UUFDakIsV0FBVztLQUNaO0lBQ0QsUUFBUSxFQUFFLENBQUMsTUFBTSxDQUFDO0NBQ25CLENBQUM7QUF1QkssS0FBSyxVQUFVLG1CQUFtQixDQUFDLEVBQ3hDLE9BQU8sRUFDUCxnQkFBZ0IsR0FBRyxJQUFJLEdBQUcsRUFBRSxFQUM1QixnQkFBZ0IsRUFDaEIsVUFBVSxHQUFHLHlCQUFpQixDQUFDLFVBQVUsRUFDekMsUUFBUSxHQUFHLHlCQUFpQixDQUFDLFFBQVEsRUFDckMsUUFBUSxHQUFHLHlCQUFpQixDQUFDLFFBQVEsRUFDckMs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QUFDLElBQUksQ0FBQyxHQUFHLENBQUM7WUFDN0MsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFN0IsSUFDRSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUM7WUFDckIsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQztZQUMzQixDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDO1lBQ3hCLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsRUFDN0I7WUFDQSxNQUFNLGVBQWUsR0FBNEIsZ0JBQWdCLENBQUMsR0FBRyxDQUNuRSxXQUFXLENBQ1osQ0FBQztZQUVGLElBQUksZUFBZSxFQUFFO2dCQUNuQixPQUFPLENBQUMsV0FBVyxDQUFDLEdBQUcsSUFBSSxlQUFlLENBQUMsT0FBTyxFQUFFLENBQUM7YUFDdEQ7aUJBQU0sSUFBSSxnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsRUFBRTtnQkFDeEMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxHQUFHLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxDQUFDO2FBQ3REO2lCQUFNLElBQUkscUJBQXFCLEtBQUssT0FBTyxFQUFFO2dCQUM1QyxNQUFNLElBQUksS0FBSyxDQUNiLHNCQUFzQixXQUFXLFdBQVcsVUFBVSxHQUFHLENBQzFELENBQUM7YUFDSDtTQUNGO0tBQ0Y7SUFFRCxPQUFPLE9BQU8sQ0FBQztBQUNqQixDQUFDO0FBakpELGtEQWlKQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGJ1aWx0aW5Nb2R1bGVzIH0gZnJvbSAnbW9kdWxlJztcbmltcG9ydCB7IFBhY2thZ2VKc29uIH0gZnJvbSAndHlwZS1mZXN0JztcbmltcG9ydCB0cyBmcm9tICd0eXBlc2NyaXB0JztcbmltcG9ydCB7IFBhY2thZ2VJbmZvIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IG5vZGVBUElMaXN0OiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQ8c3RyaW5nPihidWlsdGluTW9kdWxlcyk7XG5cbmV4cG9ydCBjb25zdCBjb2xsZWN0VHlwZVNjcmlwdDoge1xuICBleHRlbnNpb25zOiBzdHJpbmdbXTtcbiAgZXhjbHVkZXM6IHN0cmluZ1tdO1xuICBpbmNsdWRlczogc3RyaW5nW107XG59ID0ge1xuICBleHRlbnNpb25zOiBbJy50cycsICcudHN4J10sXG4gIGV4Y2x1ZGVzOiBbXG4gICAgLy8gZXhjbHVkZSB0ZXN0c1xuICAgICcqKi8qLihzcGVjfHRlc3QpLihqc3xqc3h8dHN8dHN4KScsXG4gICAgJyoqL19fKicsXG5cbiAgICAvLyBleGNsdWRlIHB1YmxpY1xuICAgICcqKi9wdWJsaWMnLFxuICAgICcqKi9iaW4nLFxuXG4gICAgLy8gZXhjbHVkZSBqYXZhc2NyaXB0XG4gICAgJyoqLyouanMnLFxuICAgICcqKi8qLmpzeCcsXG4gIF0sXG4gIGluY2x1ZGVzOiBbJyoqLyonXSxcbn07XG5cbmV4cG9ydCBjb25zdCBjb2xsZWN0U2NyaXB0czoge1xuICBleHRlbnNpb25zOiBzdHJpbmdbXTtcbiAgZXhjbHVkZXM6IHN0cmluZ1tdO1xuICBpbmNsdWRlczogc3RyaW5nW107XG59ID0ge1xuICBleHRlbnNpb25zOiBbJy5qcycsICcuanN4JywgJy50cycsICcudHN4J10sXG4gIGV4Y2x1ZGVzOiBbXG4gICAgLy8gZXhjbHVkZSB0ZXN0c1xuICAgICcqKi8qLihzcGVjfHRlc3QpLihqc3xqc3h8dHN8dHN4KScsXG4gICAgJyoqL19fKicsXG5cbiAgICAvLyBleGNsdWRlIHB1YmxpY1xuICAgICcqKi9wdWJsaWMnLFxuICAgICcqKi9iaW4nLFxuXG4gICAgLy8gZXhjbHVkZSBwdWJsaWNcbiAgICAnKiovcHVibGljJyxcbiAgXSxcbiAgaW5jbHVkZXM6IFsnKiovKiddLFxufTtcblxuaW50ZXJmYWNlIENvbGxlY3REZXBlbmRlbmNpZXNQYXJhbXMge1xuICAvLyBzb3VyY2UgZGlyZWN0b3J5XG4gIHJvb3REaXI6IHN0cmluZztcbiAgLy8gZGVwZW5kZW5jeSByZWZlcmVuY2VzXG4gIGludGVybmFsUGFja2FnZXM/OiBNYXA8c3RyaW5nLCBQYWNrYWdlSW5mbz47XG4gIGV4dGVybmFsUGFja2FnZXM6IFBhY2thZ2VKc29uLkRlcGVuZGVuY3k7XG4gIC8vIHR5cGVzY3JpcHQgY29uZmlnc1xuICBleHRlbnNpb25zPzogc3RyaW5nW107XG4gIGV4Y2x1ZGVzPzogc3RyaW5nW107XG4gIGluY2x1ZGVzPzogc3RyaW5nW107XG4gIGNvbXBpbGVyT3B0aW9ucz86IHRzLkNvbXBpbGVyT3B0aW9ucztcbiAgLy8gaWYgeW91IHdhbnQgdG8gZG8gbm90IGNvbGxlY3Qgc29tZSBkZXBlbmRlbmNpZXMgbGlrZSB0aGlzIGBpbXBvcnQge30gZnJvbSAnc2VsZi1wYWNrYWdlLW5hbWUnYFxuICAvLyB5b3UgY2FuIHBhc3MgdGhpcyBsaWtlIHsgc2VsZk5hbWVzOiBuZXcgU2V0KFsnc2VsZi1wYWNrYWdlLW5hbWUnXSkgfVxuICBzZWxmTmFtZXM/OiBTZXQ8c3RyaW5nPjtcbiAgZml4SW1wb3J0UGF0aD86IChhcmdzOiB7IGltcG9ydFBhdGg6IHN0cmluZzsgZmlsZVBhdGg6IHN0cmluZyB9KSA9PiBzdHJpbmc7XG4gIC8vIGlmIHlvdSBzZXQgdGhpcyB0byAncGFzcydcbiAgLy8gd2hlbiBmaW5kIHRoZSB1bmRlZmluZWQgcGFja2FnZSBuYW1lXG4gIC8vIGl0IGRvZXMgbm90IHRocm93IGEgZXJyb3JcbiAgY2hlY2tVbmRlZmluZWRQYWNrYWdlPzogJ2Vycm9yJyB8ICdwYXNzJztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbGxlY3REZXBlbmRlbmNpZXMoe1xuICByb290RGlyLFxuICBpbnRlcm5hbFBhY2thZ2VzID0gbmV3IE1hcCgpLFxuICBleHRlcm5hbFBhY2thZ2VzLFxuICBleHRlbnNpb25zID0gY29sbGVjdFR5cGVTY3JpcHQuZXh0ZW5zaW9ucyxcbiAgZXhjbHVkZXMgPSBjb2xsZWN0VHlwZVNjcmlwdC5leGNsdWRlcyxcbiAgaW5jbHVkZXMgPSBjb2xsZWN0VHlwZVNjcmlwdC5pbmNsdWRlcyxcbiAgY29tcGlsZXJPcHRpb25zID0ge30sXG4gIHNlbGZOYW1lcyA9IG5ldyBTZXQoKSxcbiAgZml4SW1wb3J0UGF0aCxcbiAgY2hlY2tVbmRlZmluZWRQYWNrYWdlID0gJ2Vycm9yJyxcbn06IENvbGxlY3REZXBlbmRlbmNpZXNQYXJhbXMpOiBQcm9taXNlPFBhY2thZ2VKc29uLkRlcGVuZGVuY3k+IHtcbiAgY29tcGlsZXJPcHRpb25zID0ge1xuICAgIGFsbG93SnM6IGV4dGVuc2lvbnMuc29tZSgoZXh0KSA9PiAvXi5qcy8udGVzdChleHQpKSxcbiAgICAuLi5jb21waWxlck9wdGlvbnMsXG4gICAgcm9vdERpcixcbiAgfTtcblxuICBjb25zdCBob3N0OiB0cy5Db21waWxlckhvc3QgPSB0cy5jcmVhdGVDb21waWxlckhvc3QoY29tcGlsZXJPcHRpb25zKTtcblxuICBjb25zdCBmaWxlczogc3RyaW5nW10gPSBob3N0LnJlYWREaXJlY3RvcnkhKFxuICAgIHJvb3REaXIsXG4gICAgZXh0ZW5zaW9ucyxcbiAgICBleGNsdWRlcyxcbiAgICBpbmNsdWRlcyxcbiAgKTtcblxuICBjb25zdCBwcm9ncmFtOiB0cy5Qcm9ncmFtID0gdHMuY3JlYXRlUHJvZ3JhbShmaWxlcywgY29tcGlsZXJPcHRpb25zLCBob3N0KTtcblxuICBjb25zdCBpbXBvcnRQYXRoczogU2V0PHN0cmluZz4gPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICBjb25zdCBzb3VyY2VGaWxlOiB0cy5Tb3VyY2VGaWxlIHwgdW5kZWZpbmVkID0gcHJvZ3JhbS5nZXRTb3VyY2VGaWxlKGZpbGUpO1xuXG4gICAgaWYgKCFzb3VyY2VGaWxlKSBjb250aW51ZTtcblxuICAgIGZ1bmN0aW9uIHNlYXJjaChub2RlOiB0cy5Ob2RlKSB7XG4gICAgICAvLyBpbXBvcnQgZnJvbSAnPydcbiAgICAgIGlmIChcbiAgICAgICAgdHMuaXNJbXBvcnREZWNsYXJhdGlvbihub2RlKSAmJlxuICAgICAgICB0cy5pc1N0cmluZ0xpdGVyYWxMaWtlKG5vZGUubW9kdWxlU3BlY2lmaWVyKSAmJlxuICAgICAgICBub2RlLm1vZHVsZVNwZWNpZmllci50ZXh0XG4gICAgICApIHtcbiAgICAgICAgY29uc3QgaW1wb3J0UGF0aDogc3RyaW5nID0gbm9kZS5tb2R1bGVTcGVjaWZpZXIudGV4dDtcbiAgICAgICAgaW1wb3J0UGF0aHMuYWRkKFxuICAgICAgICAgIHR5cGVvZiBmaXhJbXBvcnRQYXRoID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGZpeEltcG9ydFBhdGgoe1xuICAgICAgICAgICAgICAgIGltcG9ydFBhdGgsXG4gICAgICAgICAgICAgICAgZmlsZVBhdGg6IGZpbGUsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IGltcG9ydFBhdGgsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAvLyBpbXBvcnQoJz8nKVxuICAgICAgZWxzZSBpZiAoXG4gICAgICAgIHRzLmlzQ2FsbEV4cHJlc3Npb24obm9kZSkgJiZcbiAgICAgICAgbm9kZS5leHByZXNzaW9uLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuSW1wb3J0S2V5d29yZCAmJlxuICAgICAgICB0cy5pc1N0cmluZ0xpdGVyYWxMaWtlKG5vZGUuYXJndW1lbnRzWzBdKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGltcG9ydFBhdGg6IHN0cmluZyA9IChub2RlLmFyZ3VtZW50c1swXSBhcyB0cy5TdHJpbmdMaXRlcmFsTGlrZSlcbiAgICAgICAgICAudGV4dDtcbiAgICAgICAgaW1wb3J0UGF0aHMuYWRkKFxuICAgICAgICAgIHR5cGVvZiBmaXhJbXBvcnRQYXRoID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGZpeEltcG9ydFBhdGgoe1xuICAgICAgICAgICAgICAgIGltcG9ydFBhdGgsXG4gICAgICAgICAgICAgICAgZmlsZVBhdGg6IGZpbGUsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IGltcG9ydFBhdGgsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAvLyByZXF1aXJlLnJlc29sdmUoJz8nKVxuICAgICAgZWxzZSBpZiAoXG4gICAgICAgIHRzLmlzQ2FsbEV4cHJlc3Npb24obm9kZSkgJiZcbiAgICAgICAgdHMuaXNQcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24obm9kZS5leHByZXNzaW9uKSAmJlxuICAgICAgICB0cy5pc0lkZW50aWZpZXIobm9kZS5leHByZXNzaW9uLmV4cHJlc3Npb24pICYmXG4gICAgICAgIG5vZGUuZXhwcmVzc2lvbi5leHByZXNzaW9uLmVzY2FwZWRUZXh0ID09PSAncmVxdWlyZScgJiZcbiAgICAgICAgbm9kZS5leHByZXNzaW9uLm5hbWUuZXNjYXBlZFRleHQgPT09ICdyZXNvbHZlJyAmJlxuICAgICAgICB0cy5pc1N0cmluZ0xpdGVyYWxMaWtlKG5vZGUuYXJndW1lbnRzWzBdKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGltcG9ydFBhdGg6IHN0cmluZyA9IChub2RlLmFyZ3VtZW50c1swXSBhcyB0cy5TdHJpbmdMaXRlcmFsTGlrZSlcbiAgICAgICAgICAudGV4dDtcbiAgICAgICAgaW1wb3J0UGF0aHMuYWRkKFxuICAgICAgICAgIHR5cGVvZiBmaXhJbXBvcnRQYXRoID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGZpeEltcG9ydFBhdGgoe1xuICAgICAgICAgICAgICAgIGltcG9ydFBhdGgsXG4gICAgICAgICAgICAgICAgZmlsZVBhdGg6IGZpbGUsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IGltcG9ydFBhdGgsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAvLyByZXF1aXJlKCc/JylcbiAgICAgIGVsc2UgaWYgKFxuICAgICAgICB0cy5pc0NhbGxFeHByZXNzaW9uKG5vZGUpICYmXG4gICAgICAgIHRzLmlzSWRlbnRpZmllcihub2RlLmV4cHJlc3Npb24pICYmXG4gICAgICAgIG5vZGUuZXhwcmVzc2lvbi5lc2NhcGVkVGV4dCA9PT0gJ3JlcXVpcmUnICYmXG4gICAgICAgIHRzLmlzU3RyaW5nTGl0ZXJhbExpa2Uobm9kZS5hcmd1bWVudHNbMF0pXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgaW1wb3J0UGF0aDogc3RyaW5nID0gKG5vZGUuYXJndW1lbnRzWzBdIGFzIHRzLlN0cmluZ0xpdGVyYWxMaWtlKVxuICAgICAgICAgIC50ZXh0O1xuICAgICAgICBpbXBvcnRQYXRocy5hZGQoXG4gICAgICAgICAgdHlwZW9mIGZpeEltcG9ydFBhdGggPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gZml4SW1wb3J0UGF0aCh7XG4gICAgICAgICAgICAgICAgaW1wb3J0UGF0aCxcbiAgICAgICAgICAgICAgICBmaWxlUGF0aDogZmlsZSxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogaW1wb3J0UGF0aCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdHMuZm9yRWFjaENoaWxkKG5vZGUsIHNlYXJjaCk7XG4gICAgfVxuXG4gICAgc2VhcmNoKHNvdXJjZUZpbGUpO1xuICB9XG5cbiAgY29uc3QgaW1wb3J0czogUGFja2FnZUpzb24uRGVwZW5kZW5jeSA9IHt9O1xuXG4gIGZvciAoY29uc3QgaW1wb3J0UGF0aCBvZiBpbXBvcnRQYXRocykge1xuICAgIGNvbnN0IHBhY2thZ2VOYW1lOiBzdHJpbmcgPSAvXkAvLnRlc3QoaW1wb3J0UGF0aClcbiAgICAgID8gaW1wb3J0UGF0aC5zcGxpdCgnLycpLnNsaWNlKDAsIDIpLmpvaW4oJy8nKVxuICAgICAgOiBpbXBvcnRQYXRoLnNwbGl0KCcvJylbMF07XG5cbiAgICBpZiAoXG4gICAgICAhaW1wb3J0c1twYWNrYWdlTmFtZV0gJiZcbiAgICAgICFzZWxmTmFtZXMuaGFzKHBhY2thZ2VOYW1lKSAmJlxuICAgICAgIS9eXFwuLy50ZXN0KHBhY2thZ2VOYW1lKSAmJlxuICAgICAgIW5vZGVBUElMaXN0LmhhcyhwYWNrYWdlTmFtZSlcbiAgICApIHtcbiAgICAgIGNvbnN0IGludGVybmFsUGFja2FnZTogUGFja2FnZUluZm8gfCB1bmRlZmluZWQgPSBpbnRlcm5hbFBhY2thZ2VzLmdldChcbiAgICAgICAgcGFja2FnZU5hbWUsXG4gICAgICApO1xuXG4gICAgICBpZiAoaW50ZXJuYWxQYWNrYWdlKSB7XG4gICAgICAgIGltcG9ydHNbcGFja2FnZU5hbWVdID0gYF4ke2ludGVybmFsUGFja2FnZS52ZXJzaW9ufWA7XG4gICAgICB9IGVsc2UgaWYgKGV4dGVybmFsUGFja2FnZXNbcGFja2FnZU5hbWVdKSB7XG4gICAgICAgIGltcG9ydHNbcGFja2FnZU5hbWVdID0gZXh0ZXJuYWxQYWNrYWdlc1twYWNrYWdlTmFtZV07XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrVW5kZWZpbmVkUGFja2FnZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFVuZGVmaW5lZCBwYWNrYWdlIFwiJHtwYWNrYWdlTmFtZX1cIiBmcm9tIFwiJHtpbXBvcnRQYXRofVwiYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW1wb3J0cztcbn1cbiJdfQ==