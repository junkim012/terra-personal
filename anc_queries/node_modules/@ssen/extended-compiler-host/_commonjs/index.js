"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createExtendedCompilerHost = exports.targetExtensions = void 0;
const transform_1 = require("@ssen/transform");
const typescript_1 = __importDefault(require("typescript"));
const transformerMap = {
    html: transform_1.plainTextTransformer,
    ejs: transform_1.plainTextTransformer,
    txt: transform_1.plainTextTransformer,
    md: transform_1.plainTextTransformer,
    yml: transform_1.yamlTransformer,
    yaml: transform_1.yamlTransformer,
    jpg: transform_1.imageTransformer,
    jpeg: transform_1.imageTransformer,
    gif: transform_1.imageTransformer,
    png: transform_1.imageTransformer,
    webp: transform_1.imageTransformer,
    svg: transform_1.svgTransformer,
};
exports.targetExtensions = Object.keys(transformerMap);
function findConfig(fileName) {
    for (const ext of exports.targetExtensions) {
        if (new RegExp(`\\.${ext}\\.tsx$`).test(fileName)) {
            return transformerMap[ext];
        }
    }
    return undefined;
}
function createExtendedCompilerHost(options, setParentNodes, compilerHost = typescript_1.default.createCompilerHost(options, setParentNodes)) {
    // When user import like `import svg from './some.svg'
    // CompilerHost searches by fileExists()
    // /absoulte-path/some.svg.ts -> /absoulte-path/some.svg.tsx -> /absoulte-path/some.svg.d.ts
    function fileExists(fileName) {
        const transformer = findConfig(fileName);
        return !!transformer || compilerHost.fileExists(fileName);
    }
    // When fileExists() returns true
    // CompilerHost request the source file by getSourceFile()
    function getSourceFile(fileName, languageVersion, onError, shouldCreateNewSourceFile) {
        const transformer = findConfig(fileName);
        // if transformConfig exists this CompilerHost returns the transformed data
        if (transformer) {
            const option = /\.svg\.tsx$/.test(fileName)
                ? {
                    variant: process.env.TS_SVG_EXPORT === 'default'
                        ? 'default'
                        : 'create-react-app',
                }
                : undefined;
            const sourceText = transformer.getSourceText(option)(
            // remove .tsx
            fileName.substr(0, fileName.length - 4));
            return typescript_1.default.createSourceFile(fileName, sourceText, options.target || typescript_1.default.ScriptTarget.Latest, setParentNodes, typescript_1.default.ScriptKind.TSX);
        }
        // if not, pass to the original CompilerHost
        return compilerHost.getSourceFile(fileName, languageVersion, onError, shouldCreateNewSourceFile);
    }
    return {
        ...compilerHost,
        fileExists,
        getSourceFile,
    };
}
exports.createExtendedCompilerHost = createExtendedCompilerHost;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvQHNzZW4vZXh0ZW5kZWQtY29tcGlsZXItaG9zdC9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSwrQ0FNeUI7QUFDekIsNERBQTRCO0FBRTVCLE1BQU0sY0FBYyxHQUFnQztJQUNsRCxJQUFJLEVBQUUsZ0NBQW9CO0lBQzFCLEdBQUcsRUFBRSxnQ0FBb0I7SUFDekIsR0FBRyxFQUFFLGdDQUFvQjtJQUN6QixFQUFFLEVBQUUsZ0NBQW9CO0lBQ3hCLEdBQUcsRUFBRSwyQkFBZTtJQUNwQixJQUFJLEVBQUUsMkJBQWU7SUFDckIsR0FBRyxFQUFFLDRCQUFnQjtJQUNyQixJQUFJLEVBQUUsNEJBQWdCO0lBQ3RCLEdBQUcsRUFBRSw0QkFBZ0I7SUFDckIsR0FBRyxFQUFFLDRCQUFnQjtJQUNyQixJQUFJLEVBQUUsNEJBQWdCO0lBQ3RCLEdBQUcsRUFBRSwwQkFBYztDQUNwQixDQUFDO0FBRVcsUUFBQSxnQkFBZ0IsR0FBYSxNQUFNLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO0FBRXRFLFNBQVMsVUFBVSxDQUFDLFFBQWdCO0lBQ2xDLEtBQUssTUFBTSxHQUFHLElBQUksd0JBQWdCLEVBQUU7UUFDbEMsSUFBSSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsU0FBUyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQ2pELE9BQU8sY0FBYyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzVCO0tBQ0Y7SUFFRCxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDO0FBRUQsU0FBZ0IsMEJBQTBCLENBQ3hDLE9BQTJCLEVBQzNCLGNBQXdCLEVBQ3hCLGVBQWdDLG9CQUFFLENBQUMsa0JBQWtCLENBQ25ELE9BQU8sRUFDUCxjQUFjLENBQ2Y7SUFFRCxzREFBc0Q7SUFDdEQsd0NBQXdDO0lBQ3hDLDRGQUE0RjtJQUM1RixTQUFTLFVBQVUsQ0FBQyxRQUFnQjtRQUNsQyxNQUFNLFdBQVcsR0FBNEIsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ2xFLE9BQU8sQ0FBQyxDQUFDLFdBQVcsSUFBSSxZQUFZLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzVELENBQUM7SUFFRCxpQ0FBaUM7SUFDakMsMERBQTBEO0lBQzFELFNBQVMsYUFBYSxDQUNwQixRQUFnQixFQUNoQixlQUFnQyxFQUNoQyxPQUFtQyxFQUNuQyx5QkFBbUM7UUFFbkMsTUFBTSxXQUFXLEdBQTRCLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUVsRSwyRUFBMkU7UUFDM0UsSUFBSSxXQUFXLEVBQUU7WUFDZixNQUFNLE1BQU0sR0FBdUMsYUFBYSxDQUFDLElBQUksQ0FDbkUsUUFBUSxDQUNUO2dCQUNDLENBQUMsQ0FBQztvQkFDRSxPQUFPLEVBQ0wsT0FBTyxDQUFDLEdBQUcsQ0FBQyxhQUFhLEtBQUssU0FBUzt3QkFDckMsQ0FBQyxDQUFDLFNBQVM7d0JBQ1gsQ0FBQyxDQUFDLGtCQUFrQjtpQkFDekI7Z0JBQ0gsQ0FBQyxDQUFDLFNBQVMsQ0FBQztZQUNkLE1BQU0sVUFBVSxHQUFXLFdBQVcsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDO1lBQzFELGNBQWM7WUFDZCxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUN4QyxDQUFDO1lBQ0YsT0FBTyxvQkFBRSxDQUFDLGdCQUFnQixDQUN4QixRQUFRLEVBQ1IsVUFBVSxFQUNWLE9BQU8sQ0FBQyxNQUFNLElBQUksb0JBQUUsQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUN4QyxjQUFjLEVBQ2Qsb0JBQUUsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUNsQixDQUFDO1NBQ0g7UUFFRCw0Q0FBNEM7UUFDNUMsT0FBTyxZQUFZLENBQUMsYUFBYSxDQUMvQixRQUFRLEVBQ1IsZUFBZSxFQUNmLE9BQU8sRUFDUCx5QkFBeUIsQ0FDMUIsQ0FBQztJQUNKLENBQUM7SUFFRCxPQUFPO1FBQ0wsR0FBRyxZQUFZO1FBQ2YsVUFBVTtRQUNWLGFBQWE7S0FDZCxDQUFDO0FBQ0osQ0FBQztBQWpFRCxnRUFpRUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBpbWFnZVRyYW5zZm9ybWVyLFxuICBwbGFpblRleHRUcmFuc2Zvcm1lcixcbiAgc3ZnVHJhbnNmb3JtZXIsXG4gIFRyYW5zZm9ybWVyLFxuICB5YW1sVHJhbnNmb3JtZXIsXG59IGZyb20gJ0Bzc2VuL3RyYW5zZm9ybSc7XG5pbXBvcnQgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmNvbnN0IHRyYW5zZm9ybWVyTWFwOiBSZWNvcmQ8c3RyaW5nLCBUcmFuc2Zvcm1lcj4gPSB7XG4gIGh0bWw6IHBsYWluVGV4dFRyYW5zZm9ybWVyLFxuICBlanM6IHBsYWluVGV4dFRyYW5zZm9ybWVyLFxuICB0eHQ6IHBsYWluVGV4dFRyYW5zZm9ybWVyLFxuICBtZDogcGxhaW5UZXh0VHJhbnNmb3JtZXIsXG4gIHltbDogeWFtbFRyYW5zZm9ybWVyLFxuICB5YW1sOiB5YW1sVHJhbnNmb3JtZXIsXG4gIGpwZzogaW1hZ2VUcmFuc2Zvcm1lcixcbiAganBlZzogaW1hZ2VUcmFuc2Zvcm1lcixcbiAgZ2lmOiBpbWFnZVRyYW5zZm9ybWVyLFxuICBwbmc6IGltYWdlVHJhbnNmb3JtZXIsXG4gIHdlYnA6IGltYWdlVHJhbnNmb3JtZXIsXG4gIHN2Zzogc3ZnVHJhbnNmb3JtZXIsXG59O1xuXG5leHBvcnQgY29uc3QgdGFyZ2V0RXh0ZW5zaW9uczogc3RyaW5nW10gPSBPYmplY3Qua2V5cyh0cmFuc2Zvcm1lck1hcCk7XG5cbmZ1bmN0aW9uIGZpbmRDb25maWcoZmlsZU5hbWU6IHN0cmluZyk6IFRyYW5zZm9ybWVyIHwgdW5kZWZpbmVkIHtcbiAgZm9yIChjb25zdCBleHQgb2YgdGFyZ2V0RXh0ZW5zaW9ucykge1xuICAgIGlmIChuZXcgUmVnRXhwKGBcXFxcLiR7ZXh0fVxcXFwudHN4JGApLnRlc3QoZmlsZU5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtZXJNYXBbZXh0XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXh0ZW5kZWRDb21waWxlckhvc3QoXG4gIG9wdGlvbnM6IHRzLkNvbXBpbGVyT3B0aW9ucyxcbiAgc2V0UGFyZW50Tm9kZXM/OiBib29sZWFuLFxuICBjb21waWxlckhvc3Q6IHRzLkNvbXBpbGVySG9zdCA9IHRzLmNyZWF0ZUNvbXBpbGVySG9zdChcbiAgICBvcHRpb25zLFxuICAgIHNldFBhcmVudE5vZGVzLFxuICApLFxuKTogdHMuQ29tcGlsZXJIb3N0IHtcbiAgLy8gV2hlbiB1c2VyIGltcG9ydCBsaWtlIGBpbXBvcnQgc3ZnIGZyb20gJy4vc29tZS5zdmcnXG4gIC8vIENvbXBpbGVySG9zdCBzZWFyY2hlcyBieSBmaWxlRXhpc3RzKClcbiAgLy8gL2Fic291bHRlLXBhdGgvc29tZS5zdmcudHMgLT4gL2Fic291bHRlLXBhdGgvc29tZS5zdmcudHN4IC0+IC9hYnNvdWx0ZS1wYXRoL3NvbWUuc3ZnLmQudHNcbiAgZnVuY3Rpb24gZmlsZUV4aXN0cyhmaWxlTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdHJhbnNmb3JtZXI6IFRyYW5zZm9ybWVyIHwgdW5kZWZpbmVkID0gZmluZENvbmZpZyhmaWxlTmFtZSk7XG4gICAgcmV0dXJuICEhdHJhbnNmb3JtZXIgfHwgY29tcGlsZXJIb3N0LmZpbGVFeGlzdHMoZmlsZU5hbWUpO1xuICB9XG5cbiAgLy8gV2hlbiBmaWxlRXhpc3RzKCkgcmV0dXJucyB0cnVlXG4gIC8vIENvbXBpbGVySG9zdCByZXF1ZXN0IHRoZSBzb3VyY2UgZmlsZSBieSBnZXRTb3VyY2VGaWxlKClcbiAgZnVuY3Rpb24gZ2V0U291cmNlRmlsZShcbiAgICBmaWxlTmFtZTogc3RyaW5nLFxuICAgIGxhbmd1YWdlVmVyc2lvbjogdHMuU2NyaXB0VGFyZ2V0LFxuICAgIG9uRXJyb3I/OiAobWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkLFxuICAgIHNob3VsZENyZWF0ZU5ld1NvdXJjZUZpbGU/OiBib29sZWFuLFxuICApOiB0cy5Tb3VyY2VGaWxlIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCB0cmFuc2Zvcm1lcjogVHJhbnNmb3JtZXIgfCB1bmRlZmluZWQgPSBmaW5kQ29uZmlnKGZpbGVOYW1lKTtcblxuICAgIC8vIGlmIHRyYW5zZm9ybUNvbmZpZyBleGlzdHMgdGhpcyBDb21waWxlckhvc3QgcmV0dXJucyB0aGUgdHJhbnNmb3JtZWQgZGF0YVxuICAgIGlmICh0cmFuc2Zvcm1lcikge1xuICAgICAgY29uc3Qgb3B0aW9uOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgdW5kZWZpbmVkID0gL1xcLnN2Z1xcLnRzeCQvLnRlc3QoXG4gICAgICAgIGZpbGVOYW1lLFxuICAgICAgKVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIHZhcmlhbnQ6XG4gICAgICAgICAgICAgIHByb2Nlc3MuZW52LlRTX1NWR19FWFBPUlQgPT09ICdkZWZhdWx0J1xuICAgICAgICAgICAgICAgID8gJ2RlZmF1bHQnXG4gICAgICAgICAgICAgICAgOiAnY3JlYXRlLXJlYWN0LWFwcCcsXG4gICAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IHNvdXJjZVRleHQ6IHN0cmluZyA9IHRyYW5zZm9ybWVyLmdldFNvdXJjZVRleHQob3B0aW9uKShcbiAgICAgICAgLy8gcmVtb3ZlIC50c3hcbiAgICAgICAgZmlsZU5hbWUuc3Vic3RyKDAsIGZpbGVOYW1lLmxlbmd0aCAtIDQpLFxuICAgICAgKTtcbiAgICAgIHJldHVybiB0cy5jcmVhdGVTb3VyY2VGaWxlKFxuICAgICAgICBmaWxlTmFtZSxcbiAgICAgICAgc291cmNlVGV4dCxcbiAgICAgICAgb3B0aW9ucy50YXJnZXQgfHwgdHMuU2NyaXB0VGFyZ2V0LkxhdGVzdCxcbiAgICAgICAgc2V0UGFyZW50Tm9kZXMsXG4gICAgICAgIHRzLlNjcmlwdEtpbmQuVFNYLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBpZiBub3QsIHBhc3MgdG8gdGhlIG9yaWdpbmFsIENvbXBpbGVySG9zdFxuICAgIHJldHVybiBjb21waWxlckhvc3QuZ2V0U291cmNlRmlsZShcbiAgICAgIGZpbGVOYW1lLFxuICAgICAgbGFuZ3VhZ2VWZXJzaW9uLFxuICAgICAgb25FcnJvcixcbiAgICAgIHNob3VsZENyZWF0ZU5ld1NvdXJjZUZpbGUsXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4uY29tcGlsZXJIb3N0LFxuICAgIGZpbGVFeGlzdHMsXG4gICAgZ2V0U291cmNlRmlsZSxcbiAgfTtcbn1cbiJdfQ==