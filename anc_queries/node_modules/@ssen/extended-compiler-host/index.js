import { imageTransformer, plainTextTransformer, svgTransformer, yamlTransformer, } from '@ssen/transform';
import ts from 'typescript';
const transformerMap = {
    html: plainTextTransformer,
    ejs: plainTextTransformer,
    txt: plainTextTransformer,
    md: plainTextTransformer,
    yml: yamlTransformer,
    yaml: yamlTransformer,
    jpg: imageTransformer,
    jpeg: imageTransformer,
    gif: imageTransformer,
    png: imageTransformer,
    webp: imageTransformer,
    svg: svgTransformer,
};
export const targetExtensions = Object.keys(transformerMap);
function findConfig(fileName) {
    for (const ext of targetExtensions) {
        if (new RegExp(`\\.${ext}\\.tsx$`).test(fileName)) {
            return transformerMap[ext];
        }
    }
    return undefined;
}
export function createExtendedCompilerHost(options, setParentNodes, compilerHost = ts.createCompilerHost(options, setParentNodes)) {
    // When user import like `import svg from './some.svg'
    // CompilerHost searches by fileExists()
    // /absoulte-path/some.svg.ts -> /absoulte-path/some.svg.tsx -> /absoulte-path/some.svg.d.ts
    function fileExists(fileName) {
        const transformer = findConfig(fileName);
        return !!transformer || compilerHost.fileExists(fileName);
    }
    // When fileExists() returns true
    // CompilerHost request the source file by getSourceFile()
    function getSourceFile(fileName, languageVersion, onError, shouldCreateNewSourceFile) {
        const transformer = findConfig(fileName);
        // if transformConfig exists this CompilerHost returns the transformed data
        if (transformer) {
            const option = /\.svg\.tsx$/.test(fileName)
                ? {
                    variant: process.env.TS_SVG_EXPORT === 'default'
                        ? 'default'
                        : 'create-react-app',
                }
                : undefined;
            const sourceText = transformer.getSourceText(option)(
            // remove .tsx
            fileName.substr(0, fileName.length - 4));
            return ts.createSourceFile(fileName, sourceText, options.target || ts.ScriptTarget.Latest, setParentNodes, ts.ScriptKind.TSX);
        }
        // if not, pass to the original CompilerHost
        return compilerHost.getSourceFile(fileName, languageVersion, onError, shouldCreateNewSourceFile);
    }
    return {
        ...compilerHost,
        fileExists,
        getSourceFile,
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvQHNzZW4vZXh0ZW5kZWQtY29tcGlsZXItaG9zdC9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsZ0JBQWdCLEVBQ2hCLG9CQUFvQixFQUNwQixjQUFjLEVBRWQsZUFBZSxHQUNoQixNQUFNLGlCQUFpQixDQUFDO0FBQ3pCLE9BQU8sRUFBRSxNQUFNLFlBQVksQ0FBQztBQUU1QixNQUFNLGNBQWMsR0FBZ0M7SUFDbEQsSUFBSSxFQUFFLG9CQUFvQjtJQUMxQixHQUFHLEVBQUUsb0JBQW9CO0lBQ3pCLEdBQUcsRUFBRSxvQkFBb0I7SUFDekIsRUFBRSxFQUFFLG9CQUFvQjtJQUN4QixHQUFHLEVBQUUsZUFBZTtJQUNwQixJQUFJLEVBQUUsZUFBZTtJQUNyQixHQUFHLEVBQUUsZ0JBQWdCO0lBQ3JCLElBQUksRUFBRSxnQkFBZ0I7SUFDdEIsR0FBRyxFQUFFLGdCQUFnQjtJQUNyQixHQUFHLEVBQUUsZ0JBQWdCO0lBQ3JCLElBQUksRUFBRSxnQkFBZ0I7SUFDdEIsR0FBRyxFQUFFLGNBQWM7Q0FDcEIsQ0FBQztBQUVGLE1BQU0sQ0FBQyxNQUFNLGdCQUFnQixHQUFhLE1BQU0sQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7QUFFdEUsU0FBUyxVQUFVLENBQUMsUUFBZ0I7SUFDbEMsS0FBSyxNQUFNLEdBQUcsSUFBSSxnQkFBZ0IsRUFBRTtRQUNsQyxJQUFJLElBQUksTUFBTSxDQUFDLE1BQU0sR0FBRyxTQUFTLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDakQsT0FBTyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDNUI7S0FDRjtJQUVELE9BQU8sU0FBUyxDQUFDO0FBQ25CLENBQUM7QUFFRCxNQUFNLFVBQVUsMEJBQTBCLENBQ3hDLE9BQTJCLEVBQzNCLGNBQXdCLEVBQ3hCLGVBQWdDLEVBQUUsQ0FBQyxrQkFBa0IsQ0FDbkQsT0FBTyxFQUNQLGNBQWMsQ0FDZjtJQUVELHNEQUFzRDtJQUN0RCx3Q0FBd0M7SUFDeEMsNEZBQTRGO0lBQzVGLFNBQVMsVUFBVSxDQUFDLFFBQWdCO1FBQ2xDLE1BQU0sV0FBVyxHQUE0QixVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDbEUsT0FBTyxDQUFDLENBQUMsV0FBVyxJQUFJLFlBQVksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDNUQsQ0FBQztJQUVELGlDQUFpQztJQUNqQywwREFBMEQ7SUFDMUQsU0FBUyxhQUFhLENBQ3BCLFFBQWdCLEVBQ2hCLGVBQWdDLEVBQ2hDLE9BQW1DLEVBQ25DLHlCQUFtQztRQUVuQyxNQUFNLFdBQVcsR0FBNEIsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRWxFLDJFQUEyRTtRQUMzRSxJQUFJLFdBQVcsRUFBRTtZQUNmLE1BQU0sTUFBTSxHQUF1QyxhQUFhLENBQUMsSUFBSSxDQUNuRSxRQUFRLENBQ1Q7Z0JBQ0MsQ0FBQyxDQUFDO29CQUNFLE9BQU8sRUFDTCxPQUFPLENBQUMsR0FBRyxDQUFDLGFBQWEsS0FBSyxTQUFTO3dCQUNyQyxDQUFDLENBQUMsU0FBUzt3QkFDWCxDQUFDLENBQUMsa0JBQWtCO2lCQUN6QjtnQkFDSCxDQUFDLENBQUMsU0FBUyxDQUFDO1lBQ2QsTUFBTSxVQUFVLEdBQVcsV0FBVyxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUM7WUFDMUQsY0FBYztZQUNkLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQ3hDLENBQUM7WUFDRixPQUFPLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FDeEIsUUFBUSxFQUNSLFVBQVUsRUFDVixPQUFPLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUN4QyxjQUFjLEVBQ2QsRUFBRSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQ2xCLENBQUM7U0FDSDtRQUVELDRDQUE0QztRQUM1QyxPQUFPLFlBQVksQ0FBQyxhQUFhLENBQy9CLFFBQVEsRUFDUixlQUFlLEVBQ2YsT0FBTyxFQUNQLHlCQUF5QixDQUMxQixDQUFDO0lBQ0osQ0FBQztJQUVELE9BQU87UUFDTCxHQUFHLFlBQVk7UUFDZixVQUFVO1FBQ1YsYUFBYTtLQUNkLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgaW1hZ2VUcmFuc2Zvcm1lcixcbiAgcGxhaW5UZXh0VHJhbnNmb3JtZXIsXG4gIHN2Z1RyYW5zZm9ybWVyLFxuICBUcmFuc2Zvcm1lcixcbiAgeWFtbFRyYW5zZm9ybWVyLFxufSBmcm9tICdAc3Nlbi90cmFuc2Zvcm0nO1xuaW1wb3J0IHRzIGZyb20gJ3R5cGVzY3JpcHQnO1xuXG5jb25zdCB0cmFuc2Zvcm1lck1hcDogUmVjb3JkPHN0cmluZywgVHJhbnNmb3JtZXI+ID0ge1xuICBodG1sOiBwbGFpblRleHRUcmFuc2Zvcm1lcixcbiAgZWpzOiBwbGFpblRleHRUcmFuc2Zvcm1lcixcbiAgdHh0OiBwbGFpblRleHRUcmFuc2Zvcm1lcixcbiAgbWQ6IHBsYWluVGV4dFRyYW5zZm9ybWVyLFxuICB5bWw6IHlhbWxUcmFuc2Zvcm1lcixcbiAgeWFtbDogeWFtbFRyYW5zZm9ybWVyLFxuICBqcGc6IGltYWdlVHJhbnNmb3JtZXIsXG4gIGpwZWc6IGltYWdlVHJhbnNmb3JtZXIsXG4gIGdpZjogaW1hZ2VUcmFuc2Zvcm1lcixcbiAgcG5nOiBpbWFnZVRyYW5zZm9ybWVyLFxuICB3ZWJwOiBpbWFnZVRyYW5zZm9ybWVyLFxuICBzdmc6IHN2Z1RyYW5zZm9ybWVyLFxufTtcblxuZXhwb3J0IGNvbnN0IHRhcmdldEV4dGVuc2lvbnM6IHN0cmluZ1tdID0gT2JqZWN0LmtleXModHJhbnNmb3JtZXJNYXApO1xuXG5mdW5jdGlvbiBmaW5kQ29uZmlnKGZpbGVOYW1lOiBzdHJpbmcpOiBUcmFuc2Zvcm1lciB8IHVuZGVmaW5lZCB7XG4gIGZvciAoY29uc3QgZXh0IG9mIHRhcmdldEV4dGVuc2lvbnMpIHtcbiAgICBpZiAobmV3IFJlZ0V4cChgXFxcXC4ke2V4dH1cXFxcLnRzeCRgKS50ZXN0KGZpbGVOYW1lKSkge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyTWFwW2V4dF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV4dGVuZGVkQ29tcGlsZXJIb3N0KFxuICBvcHRpb25zOiB0cy5Db21waWxlck9wdGlvbnMsXG4gIHNldFBhcmVudE5vZGVzPzogYm9vbGVhbixcbiAgY29tcGlsZXJIb3N0OiB0cy5Db21waWxlckhvc3QgPSB0cy5jcmVhdGVDb21waWxlckhvc3QoXG4gICAgb3B0aW9ucyxcbiAgICBzZXRQYXJlbnROb2RlcyxcbiAgKSxcbik6IHRzLkNvbXBpbGVySG9zdCB7XG4gIC8vIFdoZW4gdXNlciBpbXBvcnQgbGlrZSBgaW1wb3J0IHN2ZyBmcm9tICcuL3NvbWUuc3ZnJ1xuICAvLyBDb21waWxlckhvc3Qgc2VhcmNoZXMgYnkgZmlsZUV4aXN0cygpXG4gIC8vIC9hYnNvdWx0ZS1wYXRoL3NvbWUuc3ZnLnRzIC0+IC9hYnNvdWx0ZS1wYXRoL3NvbWUuc3ZnLnRzeCAtPiAvYWJzb3VsdGUtcGF0aC9zb21lLnN2Zy5kLnRzXG4gIGZ1bmN0aW9uIGZpbGVFeGlzdHMoZmlsZU5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHRyYW5zZm9ybWVyOiBUcmFuc2Zvcm1lciB8IHVuZGVmaW5lZCA9IGZpbmRDb25maWcoZmlsZU5hbWUpO1xuICAgIHJldHVybiAhIXRyYW5zZm9ybWVyIHx8IGNvbXBpbGVySG9zdC5maWxlRXhpc3RzKGZpbGVOYW1lKTtcbiAgfVxuXG4gIC8vIFdoZW4gZmlsZUV4aXN0cygpIHJldHVybnMgdHJ1ZVxuICAvLyBDb21waWxlckhvc3QgcmVxdWVzdCB0aGUgc291cmNlIGZpbGUgYnkgZ2V0U291cmNlRmlsZSgpXG4gIGZ1bmN0aW9uIGdldFNvdXJjZUZpbGUoXG4gICAgZmlsZU5hbWU6IHN0cmluZyxcbiAgICBsYW5ndWFnZVZlcnNpb246IHRzLlNjcmlwdFRhcmdldCxcbiAgICBvbkVycm9yPzogKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZCxcbiAgICBzaG91bGRDcmVhdGVOZXdTb3VyY2VGaWxlPzogYm9vbGVhbixcbiAgKTogdHMuU291cmNlRmlsZSB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgdHJhbnNmb3JtZXI6IFRyYW5zZm9ybWVyIHwgdW5kZWZpbmVkID0gZmluZENvbmZpZyhmaWxlTmFtZSk7XG5cbiAgICAvLyBpZiB0cmFuc2Zvcm1Db25maWcgZXhpc3RzIHRoaXMgQ29tcGlsZXJIb3N0IHJldHVybnMgdGhlIHRyYW5zZm9ybWVkIGRhdGFcbiAgICBpZiAodHJhbnNmb3JtZXIpIHtcbiAgICAgIGNvbnN0IG9wdGlvbjogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IHVuZGVmaW5lZCA9IC9cXC5zdmdcXC50c3gkLy50ZXN0KFxuICAgICAgICBmaWxlTmFtZSxcbiAgICAgIClcbiAgICAgICAgPyB7XG4gICAgICAgICAgICB2YXJpYW50OlxuICAgICAgICAgICAgICBwcm9jZXNzLmVudi5UU19TVkdfRVhQT1JUID09PSAnZGVmYXVsdCdcbiAgICAgICAgICAgICAgICA/ICdkZWZhdWx0J1xuICAgICAgICAgICAgICAgIDogJ2NyZWF0ZS1yZWFjdC1hcHAnLFxuICAgICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICBjb25zdCBzb3VyY2VUZXh0OiBzdHJpbmcgPSB0cmFuc2Zvcm1lci5nZXRTb3VyY2VUZXh0KG9wdGlvbikoXG4gICAgICAgIC8vIHJlbW92ZSAudHN4XG4gICAgICAgIGZpbGVOYW1lLnN1YnN0cigwLCBmaWxlTmFtZS5sZW5ndGggLSA0KSxcbiAgICAgICk7XG4gICAgICByZXR1cm4gdHMuY3JlYXRlU291cmNlRmlsZShcbiAgICAgICAgZmlsZU5hbWUsXG4gICAgICAgIHNvdXJjZVRleHQsXG4gICAgICAgIG9wdGlvbnMudGFyZ2V0IHx8IHRzLlNjcmlwdFRhcmdldC5MYXRlc3QsXG4gICAgICAgIHNldFBhcmVudE5vZGVzLFxuICAgICAgICB0cy5TY3JpcHRLaW5kLlRTWCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gaWYgbm90LCBwYXNzIHRvIHRoZSBvcmlnaW5hbCBDb21waWxlckhvc3RcbiAgICByZXR1cm4gY29tcGlsZXJIb3N0LmdldFNvdXJjZUZpbGUoXG4gICAgICBmaWxlTmFtZSxcbiAgICAgIGxhbmd1YWdlVmVyc2lvbixcbiAgICAgIG9uRXJyb3IsXG4gICAgICBzaG91bGRDcmVhdGVOZXdTb3VyY2VGaWxlLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLmNvbXBpbGVySG9zdCxcbiAgICBmaWxlRXhpc3RzLFxuICAgIGdldFNvdXJjZUZpbGUsXG4gIH07XG59XG4iXX0=