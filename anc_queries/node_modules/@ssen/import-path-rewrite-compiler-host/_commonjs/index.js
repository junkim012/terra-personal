"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createImportPathRewriteCompilerHost = void 0;
const import_path_rewrite_1 = require("@ssen/import-path-rewrite");
const typescript_1 = __importDefault(require("typescript"));
const createImportPathRewriteCompilerHost = ({ src, rootDir, }) => (options, setParentNodes, compilerHost = typescript_1.default.createCompilerHost(options, setParentNodes)) => {
    // wrap getSourceFile
    function getSourceFile(fileName, languageVersion, onError, shouldCreateNewSourceFile) {
        // get origin compiler host result
        const sourceFile = compilerHost.getSourceFile(fileName, languageVersion, onError, shouldCreateNewSourceFile);
        return sourceFile
            ? // if fileName starts with rootDir
                // for example, "/project/root/src/<package>/file.ts" starts with "/project/root/src/<package>"
                fileName.replace(/\\/g, '/').indexOf(rootDir.replace(/\\/g, '/')) > -1
                    ? // transform import paths in import, import(), require() and require.resolve() files
                        typescript_1.default.transform(sourceFile, [import_path_rewrite_1.importPathRewrite({ src, fileName })], options).transformed[0]
                    : sourceFile
            : undefined;
    }
    // create wrapped compiler host
    return {
        ...compilerHost,
        getSourceFile,
    };
};
exports.createImportPathRewriteCompilerHost = createImportPathRewriteCompilerHost;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvQHNzZW4vaW1wb3J0LXBhdGgtcmV3cml0ZS1jb21waWxlci1ob3N0L2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLG1FQUE4RDtBQUM5RCw0REFBNEI7QUFrQnJCLE1BQU0sbUNBQW1DLEdBQUcsQ0FBQyxFQUNsRCxHQUFHLEVBQ0gsT0FBTyxHQUNPLEVBQUUsRUFBRSxDQUFDLENBQ25CLE9BQTJCLEVBQzNCLGNBQXdCLEVBQ3hCLGVBQWdDLG9CQUFFLENBQUMsa0JBQWtCLENBQ25ELE9BQU8sRUFDUCxjQUFjLENBQ2YsRUFDZ0IsRUFBRTtJQUNuQixxQkFBcUI7SUFDckIsU0FBUyxhQUFhLENBQ3BCLFFBQWdCLEVBQ2hCLGVBQWdDLEVBQ2hDLE9BQW1DLEVBQ25DLHlCQUFtQztRQUVuQyxrQ0FBa0M7UUFDbEMsTUFBTSxVQUFVLEdBQThCLFlBQVksQ0FBQyxhQUFhLENBQ3RFLFFBQVEsRUFDUixlQUFlLEVBQ2YsT0FBTyxFQUNQLHlCQUF5QixDQUMxQixDQUFDO1FBRUYsT0FBTyxVQUFVO1lBQ2YsQ0FBQyxDQUFDLGtDQUFrQztnQkFDbEMsK0ZBQStGO2dCQUMvRixRQUFRLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQ3RFLENBQUMsQ0FBQyxvRkFBb0Y7d0JBQ3BGLG9CQUFFLENBQUMsU0FBUyxDQUNWLFVBQVUsRUFDVixDQUFDLHVDQUFpQixDQUFDLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxDQUFDLENBQUMsRUFDdEMsT0FBTyxDQUNSLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztvQkFDbEIsQ0FBQyxDQUFDLFVBQVU7WUFDZCxDQUFDLENBQUMsU0FBUyxDQUFDO0lBQ2hCLENBQUM7SUFFRCwrQkFBK0I7SUFDL0IsT0FBTztRQUNMLEdBQUcsWUFBWTtRQUNmLGFBQWE7S0FDZCxDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBN0NXLFFBQUEsbUNBQW1DLHVDQTZDOUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbXBvcnRQYXRoUmV3cml0ZSB9IGZyb20gJ0Bzc2VuL2ltcG9ydC1wYXRoLXJld3JpdGUnO1xuaW1wb3J0IHRzIGZyb20gJ3R5cGVzY3JpcHQnO1xuXG5pbnRlcmZhY2UgQ29uZmlndXJhdGlvbiB7XG4gIC8qKlxuICAgKiBzb3VyY2Ugcm9vdFxuICAgKlxuICAgKiAvcHJvamVjdC9yb290L3NyY1xuICAgKi9cbiAgc3JjOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIHBhY2thZ2Ugc291cmNlIGRpcmVjdG9yeVxuICAgKlxuICAgKiAvcHJvamVjdC9yb290L3NyYy88cGFja2FnZT5cbiAgICovXG4gIHJvb3REaXI6IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUltcG9ydFBhdGhSZXdyaXRlQ29tcGlsZXJIb3N0ID0gKHtcbiAgc3JjLFxuICByb290RGlyLFxufTogQ29uZmlndXJhdGlvbikgPT4gKFxuICBvcHRpb25zOiB0cy5Db21waWxlck9wdGlvbnMsXG4gIHNldFBhcmVudE5vZGVzPzogYm9vbGVhbixcbiAgY29tcGlsZXJIb3N0OiB0cy5Db21waWxlckhvc3QgPSB0cy5jcmVhdGVDb21waWxlckhvc3QoXG4gICAgb3B0aW9ucyxcbiAgICBzZXRQYXJlbnROb2RlcyxcbiAgKSxcbik6IHRzLkNvbXBpbGVySG9zdCA9PiB7XG4gIC8vIHdyYXAgZ2V0U291cmNlRmlsZVxuICBmdW5jdGlvbiBnZXRTb3VyY2VGaWxlKFxuICAgIGZpbGVOYW1lOiBzdHJpbmcsXG4gICAgbGFuZ3VhZ2VWZXJzaW9uOiB0cy5TY3JpcHRUYXJnZXQsXG4gICAgb25FcnJvcj86IChtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWQsXG4gICAgc2hvdWxkQ3JlYXRlTmV3U291cmNlRmlsZT86IGJvb2xlYW4sXG4gICk6IHRzLlNvdXJjZUZpbGUgfCB1bmRlZmluZWQge1xuICAgIC8vIGdldCBvcmlnaW4gY29tcGlsZXIgaG9zdCByZXN1bHRcbiAgICBjb25zdCBzb3VyY2VGaWxlOiB0cy5Tb3VyY2VGaWxlIHwgdW5kZWZpbmVkID0gY29tcGlsZXJIb3N0LmdldFNvdXJjZUZpbGUoXG4gICAgICBmaWxlTmFtZSxcbiAgICAgIGxhbmd1YWdlVmVyc2lvbixcbiAgICAgIG9uRXJyb3IsXG4gICAgICBzaG91bGRDcmVhdGVOZXdTb3VyY2VGaWxlLFxuICAgICk7XG5cbiAgICByZXR1cm4gc291cmNlRmlsZVxuICAgICAgPyAvLyBpZiBmaWxlTmFtZSBzdGFydHMgd2l0aCByb290RGlyXG4gICAgICAgIC8vIGZvciBleGFtcGxlLCBcIi9wcm9qZWN0L3Jvb3Qvc3JjLzxwYWNrYWdlPi9maWxlLnRzXCIgc3RhcnRzIHdpdGggXCIvcHJvamVjdC9yb290L3NyYy88cGFja2FnZT5cIlxuICAgICAgICBmaWxlTmFtZS5yZXBsYWNlKC9cXFxcL2csICcvJykuaW5kZXhPZihyb290RGlyLnJlcGxhY2UoL1xcXFwvZywgJy8nKSkgPiAtMVxuICAgICAgICA/IC8vIHRyYW5zZm9ybSBpbXBvcnQgcGF0aHMgaW4gaW1wb3J0LCBpbXBvcnQoKSwgcmVxdWlyZSgpIGFuZCByZXF1aXJlLnJlc29sdmUoKSBmaWxlc1xuICAgICAgICAgIHRzLnRyYW5zZm9ybShcbiAgICAgICAgICAgIHNvdXJjZUZpbGUsXG4gICAgICAgICAgICBbaW1wb3J0UGF0aFJld3JpdGUoeyBzcmMsIGZpbGVOYW1lIH0pXSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgKS50cmFuc2Zvcm1lZFswXVxuICAgICAgICA6IHNvdXJjZUZpbGVcbiAgICAgIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gY3JlYXRlIHdyYXBwZWQgY29tcGlsZXIgaG9zdFxuICByZXR1cm4ge1xuICAgIC4uLmNvbXBpbGVySG9zdCxcbiAgICBnZXRTb3VyY2VGaWxlLFxuICB9O1xufTtcbiJdfQ==