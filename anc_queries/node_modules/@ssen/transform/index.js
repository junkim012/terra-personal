import svgToJsx from '@svgr/plugin-jsx';
import fs from 'fs-extra';
import yaml from 'js-yaml';
import svgToMiniDataURI from 'mini-svg-data-uri';
import path from 'path';
export const plainTextTransformer = {
    getSourceText: () => (file) => {
        const content = fs.readFileSync(file, 'utf8');
        return `export default '${content}'`;
    },
};
export const imageTransformer = {
    getSourceText: () => (file) => {
        const ext = path.extname(file);
        const source = fs
            .readFileSync(file, 'base64')
            .replace(/[\r\n]+/gm, '');
        return `export default 'data:image/${ext};base64,${source}'`;
    },
};
export const yamlTransformer = {
    getSourceText: () => (file) => {
        const content = fs.readFileSync(file, 'utf8');
        return `export default ${JSON.stringify(yaml.load(content))}`;
    },
};
export const svgTransformer = {
    /**
     * When option.variant is 'default', it will be `import ReactComponent from './some.svg'`
     * When option.variant is 'create-react-app', it will be `import svgUrl, { ReactComponent } from './some.svg'`
     *
     * @param option { variant: 'create-react-app' | 'default' } default is 'create-react-app'
     */
    getSourceText: (option) => (file) => {
        const svgCode = fs
            .readFileSync(file, 'utf8')
            .replace(/[\r\n]+/gm, '');
        const componentName = 'ReactComponent';
        const reactCode = svgToJsx(svgCode, {}, { componentName });
        if ((option === null || option === void 0 ? void 0 : option.variant) === 'default') {
            return reactCode;
        }
        const lines = reactCode.split('\n');
        return [
            ...lines.slice(0, lines.length - 1),
            `export default \`${svgToMiniDataURI(svgCode)}\`;`,
            `export {${componentName}};`,
        ].join('\n');
    },
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvQHNzZW4vdHJhbnNmb3JtL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sUUFBUSxNQUFNLGtCQUFrQixDQUFDO0FBQ3hDLE9BQU8sRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUMxQixPQUFPLElBQUksTUFBTSxTQUFTLENBQUM7QUFDM0IsT0FBTyxnQkFBZ0IsTUFBTSxtQkFBbUIsQ0FBQztBQUNqRCxPQUFPLElBQUksTUFBTSxNQUFNLENBQUM7QUFXeEIsTUFBTSxDQUFDLE1BQU0sb0JBQW9CLEdBQWdCO0lBQy9DLGFBQWEsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLElBQVksRUFBRSxFQUFFO1FBQ3BDLE1BQU0sT0FBTyxHQUFXLEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3RELE9BQU8sbUJBQW1CLE9BQU8sR0FBRyxDQUFDO0lBQ3ZDLENBQUM7Q0FDRixDQUFDO0FBRUYsTUFBTSxDQUFDLE1BQU0sZ0JBQWdCLEdBQWdCO0lBQzNDLGFBQWEsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLElBQVksRUFBRSxFQUFFO1FBQ3BDLE1BQU0sR0FBRyxHQUFXLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdkMsTUFBTSxNQUFNLEdBQVcsRUFBRTthQUN0QixZQUFZLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQzthQUM1QixPQUFPLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQzVCLE9BQU8sOEJBQThCLEdBQUcsV0FBVyxNQUFNLEdBQUcsQ0FBQztJQUMvRCxDQUFDO0NBQ0YsQ0FBQztBQUVGLE1BQU0sQ0FBQyxNQUFNLGVBQWUsR0FBZ0I7SUFDMUMsYUFBYSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsSUFBWSxFQUFFLEVBQUU7UUFDcEMsTUFBTSxPQUFPLEdBQVcsRUFBRSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDdEQsT0FBTyxrQkFBa0IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUNoRSxDQUFDO0NBQ0YsQ0FBQztBQUVGLE1BQU0sQ0FBQyxNQUFNLGNBQWMsR0FBZ0I7SUFDekM7Ozs7O09BS0c7SUFDSCxhQUFhLEVBQUUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLENBQUMsSUFBWSxFQUFFLEVBQUU7UUFDMUMsTUFBTSxPQUFPLEdBQVcsRUFBRTthQUN2QixZQUFZLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQzthQUMxQixPQUFPLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQzVCLE1BQU0sYUFBYSxHQUFXLGdCQUFnQixDQUFDO1FBQy9DLE1BQU0sU0FBUyxHQUFXLFFBQVEsQ0FBQyxPQUFPLEVBQUUsRUFBRSxFQUFFLEVBQUUsYUFBYSxFQUFFLENBQUMsQ0FBQztRQUVuRSxJQUFJLENBQUEsTUFBTSxhQUFOLE1BQU0sdUJBQU4sTUFBTSxDQUFFLE9BQU8sTUFBSyxTQUFTLEVBQUU7WUFDakMsT0FBTyxTQUFTLENBQUM7U0FDbEI7UUFFRCxNQUFNLEtBQUssR0FBYSxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzlDLE9BQU87WUFDTCxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1lBQ25DLG9CQUFvQixnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsS0FBSztZQUNsRCxXQUFXLGFBQWEsSUFBSTtTQUM3QixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNmLENBQUM7Q0FDRixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHN2Z1RvSnN4IGZyb20gJ0BzdmdyL3BsdWdpbi1qc3gnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCB5YW1sIGZyb20gJ2pzLXlhbWwnO1xuaW1wb3J0IHN2Z1RvTWluaURhdGFVUkkgZnJvbSAnbWluaS1zdmctZGF0YS11cmknO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNmb3JtZXIge1xuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBmaWxlIHRvIGFuIHNvdXJjZSB0ZXh0XG4gICAqXG4gICAqIEBwYXJhbSBmaWxlIEFuIGFic29sdXRlIHBhdGggbGlrZSAvYWJzb2x1dGUtcGF0aC9zb21lLnN2Z1xuICAgKi9cbiAgZ2V0U291cmNlVGV4dDogKG9wdGlvbj86IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pID0+IChmaWxlOiBzdHJpbmcpID0+IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IHBsYWluVGV4dFRyYW5zZm9ybWVyOiBUcmFuc2Zvcm1lciA9IHtcbiAgZ2V0U291cmNlVGV4dDogKCkgPT4gKGZpbGU6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IGNvbnRlbnQ6IHN0cmluZyA9IGZzLnJlYWRGaWxlU3luYyhmaWxlLCAndXRmOCcpO1xuICAgIHJldHVybiBgZXhwb3J0IGRlZmF1bHQgJyR7Y29udGVudH0nYDtcbiAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBpbWFnZVRyYW5zZm9ybWVyOiBUcmFuc2Zvcm1lciA9IHtcbiAgZ2V0U291cmNlVGV4dDogKCkgPT4gKGZpbGU6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IGV4dDogc3RyaW5nID0gcGF0aC5leHRuYW1lKGZpbGUpO1xuICAgIGNvbnN0IHNvdXJjZTogc3RyaW5nID0gZnNcbiAgICAgIC5yZWFkRmlsZVN5bmMoZmlsZSwgJ2Jhc2U2NCcpXG4gICAgICAucmVwbGFjZSgvW1xcclxcbl0rL2dtLCAnJyk7XG4gICAgcmV0dXJuIGBleHBvcnQgZGVmYXVsdCAnZGF0YTppbWFnZS8ke2V4dH07YmFzZTY0LCR7c291cmNlfSdgO1xuICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IHlhbWxUcmFuc2Zvcm1lcjogVHJhbnNmb3JtZXIgPSB7XG4gIGdldFNvdXJjZVRleHQ6ICgpID0+IChmaWxlOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBjb250ZW50OiBzdHJpbmcgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZSwgJ3V0ZjgnKTtcbiAgICByZXR1cm4gYGV4cG9ydCBkZWZhdWx0ICR7SlNPTi5zdHJpbmdpZnkoeWFtbC5sb2FkKGNvbnRlbnQpKX1gO1xuICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IHN2Z1RyYW5zZm9ybWVyOiBUcmFuc2Zvcm1lciA9IHtcbiAgLyoqXG4gICAqIFdoZW4gb3B0aW9uLnZhcmlhbnQgaXMgJ2RlZmF1bHQnLCBpdCB3aWxsIGJlIGBpbXBvcnQgUmVhY3RDb21wb25lbnQgZnJvbSAnLi9zb21lLnN2ZydgXG4gICAqIFdoZW4gb3B0aW9uLnZhcmlhbnQgaXMgJ2NyZWF0ZS1yZWFjdC1hcHAnLCBpdCB3aWxsIGJlIGBpbXBvcnQgc3ZnVXJsLCB7IFJlYWN0Q29tcG9uZW50IH0gZnJvbSAnLi9zb21lLnN2ZydgXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb24geyB2YXJpYW50OiAnY3JlYXRlLXJlYWN0LWFwcCcgfCAnZGVmYXVsdCcgfSBkZWZhdWx0IGlzICdjcmVhdGUtcmVhY3QtYXBwJ1xuICAgKi9cbiAgZ2V0U291cmNlVGV4dDogKG9wdGlvbikgPT4gKGZpbGU6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHN2Z0NvZGU6IHN0cmluZyA9IGZzXG4gICAgICAucmVhZEZpbGVTeW5jKGZpbGUsICd1dGY4JylcbiAgICAgIC5yZXBsYWNlKC9bXFxyXFxuXSsvZ20sICcnKTtcbiAgICBjb25zdCBjb21wb25lbnROYW1lOiBzdHJpbmcgPSAnUmVhY3RDb21wb25lbnQnO1xuICAgIGNvbnN0IHJlYWN0Q29kZTogc3RyaW5nID0gc3ZnVG9Kc3goc3ZnQ29kZSwge30sIHsgY29tcG9uZW50TmFtZSB9KTtcblxuICAgIGlmIChvcHRpb24/LnZhcmlhbnQgPT09ICdkZWZhdWx0Jykge1xuICAgICAgcmV0dXJuIHJlYWN0Q29kZTtcbiAgICB9XG5cbiAgICBjb25zdCBsaW5lczogc3RyaW5nW10gPSByZWFjdENvZGUuc3BsaXQoJ1xcbicpO1xuICAgIHJldHVybiBbXG4gICAgICAuLi5saW5lcy5zbGljZSgwLCBsaW5lcy5sZW5ndGggLSAxKSxcbiAgICAgIGBleHBvcnQgZGVmYXVsdCBcXGAke3N2Z1RvTWluaURhdGFVUkkoc3ZnQ29kZSl9XFxgO2AsXG4gICAgICBgZXhwb3J0IHske2NvbXBvbmVudE5hbWV9fTtgLFxuICAgIF0uam9pbignXFxuJyk7XG4gIH0sXG59O1xuIl19