"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.build = void 0;
const bundle_import_rewrite_1 = require("@ssen/bundle-import-rewrite");
const collect_dependencies_1 = require("@ssen/collect-dependencies");
const extended_compiler_host_1 = require("@ssen/extended-compiler-host");
const flat_package_name_1 = require("@ssen/flat-package-name");
const import_path_rewrite_compiler_host_1 = require("@ssen/import-path-rewrite-compiler-host");
const promised_1 = require("@ssen/promised");
const rewrite_src_path_1 = require("@ssen/rewrite-src-path");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const process_1 = __importDefault(require("process"));
const typescript_1 = __importDefault(require("typescript"));
const readPackages_1 = require("./entry/readPackages");
const build_1 = require("./message-handlers/build");
const computePackageJson_1 = require("./package-json/computePackageJson");
const getExports_1 = require("./package-json/getExports");
const getRootDependencies_1 = require("./package-json/getRootDependencies");
const getSharedPackageJson_1 = require("./package-json/getSharedPackageJson");
const fsCopyFilter_1 = require("./rule/fsCopyFilter");
const getCompilerOptions_1 = require("./rule/getCompilerOptions");
const readDirectoryPatterns_1 = require("./rule/readDirectoryPatterns");
async function build({ cwd = process_1.default.cwd(), sourceRoot = 'src', strict = false, showPackagesOrder = false, dist = path_1.default.resolve(cwd, 'out/packages'), tsconfig = 'tsconfig.json', entry, svg = 'create-react-app', transformPackageJson, transformCompilerHost, transformCompilerOptions, emitCustomTransformers, onMessage = build_1.buildMessageHandler, }) {
    var _a, _b;
    // ---------------------------------------------
    // set env
    // ---------------------------------------------
    if (svg === 'default') {
        process_1.default.env.TS_SVG_EXPORT = 'default';
    }
    // ---------------------------------------------
    // rule
    // collect information based on directory rules
    // ---------------------------------------------
    const internalPackages = await readPackages_1.readPackages({
        cwd,
        sourceRoot,
        entry,
    });
    const externalPackages = await getRootDependencies_1.getRootDependencies({
        cwd,
    });
    const sharedConfig = await getSharedPackageJson_1.getSharedPackageJson({ cwd });
    // ---------------------------------------------
    // entry
    // create build options based on rule output
    // ---------------------------------------------
    const dependenciesMap = new Map();
    // collect dependencies each package
    for (const packageName of internalPackages.keys()) {
        const imports = await collect_dependencies_1.collectDependencies({
            // collect dependencies from sources on {cwd}/src/{package}
            rootDir: path_1.default.resolve(cwd, sourceRoot, packageName),
            internalPackages: internalPackages,
            externalPackages,
            selfNames: new Set([packageName]),
            checkUndefinedPackage: 'error',
            fixImportPath: ({ importPath, filePath }) => rewrite_src_path_1.rewriteSrcPath({
                rootDir: path_1.default.resolve(cwd, sourceRoot),
                importPath,
                filePath,
            }),
            ...collect_dependencies_1.collectScripts,
        });
        dependenciesMap.set(packageName, imports);
    }
    const packageJsonMap = new Map();
    // compute package.json contents each package
    for (const [packageName, packageInfo] of internalPackages) {
        const dependencies = dependenciesMap.get(packageName);
        if (!dependencies) {
            throw new Error(`undefiend dependencies of ${packageName}`);
        }
        //const packageDir: string = path.resolve(cwd, sourceRoot, packageName);
        // compute package.json
        const computedPackageJson = await computePackageJson_1.computePackageJson({
            packageInfo,
            sharedConfig,
            dependencies,
        });
        // transform package.json contents if user did set the transformPackageJson() function
        const packageJson = typeof transformPackageJson === 'function'
            ? transformPackageJson(packageName)(computedPackageJson)
            : computedPackageJson;
        packageJsonMap.set(packageName, packageJson);
    }
    // get package build order
    // it will sort depends on packages dependency relationship
    const packagesOrder = await collect_dependencies_1.getPackagesOrder({
        packageJsonContents: Array.from(packageJsonMap.values()),
    });
    const order = packagesOrder.map(({ name }) => name);
    if (showPackagesOrder) {
        console.log('packages order:', order.join(', '));
        await fs_extra_1.default.writeFile(path_1.default.join(dist, 'packageJsonMap.json'), JSON.stringify(Array.from(packageJsonMap.values()), null, 2));
        console.log(`packageJson files saved in "${path_1.default.join(dist, 'packageJsonMap.json')}"`);
    }
    // ---------------------------------------------
    // run
    // build packages
    // ---------------------------------------------
    const symlinkDirs = [];
    // ================================================================
    // build each packages
    // ================================================================
    for (const packageName of order) {
        const packageInfo = internalPackages.get(packageName);
        if (!packageInfo) {
            throw new Error(`Undefined packageInfo of ${packageName}`);
        }
        const sourceDir = path_1.default.resolve(cwd, sourceRoot, packageName);
        const outDir = path_1.default.resolve(dist, flat_package_name_1.flatPackageName(packageName));
        const packageJson = packageJsonMap.get(packageName);
        if (!packageJson) {
            throw new Error(`undefined packagejson content!`);
        }
        await onMessage({
            type: 'begin',
            packageName,
            sourceDir,
            outDir,
        });
        // ---------------------------------------------
        // clean
        // ---------------------------------------------
        await promised_1.rimraf(outDir);
        await fs_extra_1.default.mkdirp(outDir);
        // ---------------------------------------------
        // symlink
        // this symlink will be reference to next build packages
        // ---------------------------------------------
        const symlink = path_1.default.resolve(cwd, 'node_modules', packageName);
        if (fs_extra_1.default.existsSync(symlink) && fs_extra_1.default.lstatSync(symlink).isSymbolicLink()) {
            fs_extra_1.default.unlinkSync(symlink);
        }
        await fs_extra_1.default.mkdirp(path_1.default.dirname(symlink));
        await fs_extra_1.default.symlink(outDir, symlink);
        symlinkDirs.push(symlink);
        // ---------------------------------------------
        // tsc
        // ---------------------------------------------
        const buildTypes = [];
        if (packageInfo.exports.module)
            buildTypes.push('module');
        if (packageInfo.exports.commonjs)
            buildTypes.push('commonjs');
        for (const buildType of buildTypes) {
            const isMainBuild = buildType === packageInfo.exports.main;
            // read compilerOptions from {cwd}/tsconfig.json
            const userCompilerOptions = getCompilerOptions_1.getCompilerOptions({
                searchPath: cwd,
                configName: tsconfig,
                packageInfo,
                buildType,
                declaration: isMainBuild,
            });
            // compute package.json with add some build information
            const computedCompilerOptions = {
                ...userCompilerOptions,
                baseUrl: sourceDir,
                paths: {
                    ...userCompilerOptions.paths,
                    [packageName]: ['.'],
                    [packageName + '/*']: ['./*'],
                },
                rootDir: sourceDir,
                outDir: isMainBuild ? outDir : path_1.default.join(outDir, `_${buildType}`),
                incremental: true,
                tsBuildInfoFile: path_1.default.join(dist, flat_package_name_1.flatPackageName(packageName) + '.tsbuildinfo'),
            };
            // transform compilerOptions if user set the transformCompilerOptions() function
            const compilerOptions = typeof transformCompilerOptions === 'function'
                ? transformCompilerOptions(packageName)(computedCompilerOptions)
                : computedCompilerOptions;
            // create compilerHost
            const extendedHost = extended_compiler_host_1.createExtendedCompilerHost(compilerOptions);
            const pathRewriteHost = import_path_rewrite_compiler_host_1.createImportPathRewriteCompilerHost({
                src: path_1.default.resolve(cwd, sourceRoot),
                rootDir: sourceDir,
            })(compilerOptions, undefined, extendedHost);
            // transform compilerHost if user set the transformCompilerHost() function
            const host = typeof transformCompilerHost === 'function'
                ? transformCompilerHost(packageName)(compilerOptions, pathRewriteHost)
                : pathRewriteHost;
            const files = host.readDirectory(sourceDir, ...readDirectoryPatterns_1.readDirectoryPatterns);
            const program = typescript_1.default.createProgram(files, compilerOptions, host);
            const customTransformers = typeof emitCustomTransformers === 'function'
                ? (_a = emitCustomTransformers(packageName)()) !== null && _a !== void 0 ? _a : {}
                : {};
            customTransformers.after = [
                ...((_b = customTransformers.after) !== null && _b !== void 0 ? _b : []),
                bundle_import_rewrite_1.bundleImportRewrite({}),
            ];
            // 🔥 compile!!!!!!!!!
            const emitResult = program.emit(undefined, undefined, undefined, undefined, customTransformers);
            const diagnostics = typescript_1.default
                .getPreEmitDiagnostics(program)
                .concat(emitResult.diagnostics);
            await onMessage({
                type: 'tsc',
                packageName,
                compilerOptions,
                diagnostics,
            });
            if ((strict && diagnostics.length > 0) || emitResult.emitSkipped) {
                throw new Error(`Build "${packageName}" is failed`);
            }
        }
        // ---------------------------------------------
        // copy static files
        // ---------------------------------------------
        await fs_extra_1.default.copy(path_1.default.resolve(cwd, sourceRoot, packageName), outDir, {
            filter: fsCopyFilter_1.fsCopyFilter,
        });
        packageJson.exports = await getExports_1.getExports(packageInfo.exports, outDir);
        // ---------------------------------------------
        // create package.json
        // ---------------------------------------------
        await fs_extra_1.default.writeJson(path_1.default.resolve(outDir, 'package.json'), packageJson, {
            encoding: 'utf8',
            spaces: 2,
        });
        await onMessage({
            type: 'package-json',
            packageName,
            packageJson,
        });
        await onMessage({
            type: 'success',
            packageJson,
            packageName,
            sourceDir,
            outDir,
        });
    }
    // clean symlinks on node_modules
    for (const symlink of symlinkDirs) {
        fs_extra_1.default.unlinkSync(symlink);
    }
}
exports.build = build;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVpbGQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvcm9ja2V0LXB1bmNoL2J1aWxkLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLHVFQUFrRTtBQUNsRSxxRUFJb0M7QUFDcEMseUVBQTBFO0FBQzFFLCtEQUEwRDtBQUMxRCwrRkFBOEY7QUFDOUYsNkNBQXdDO0FBQ3hDLDZEQUF3RDtBQUN4RCx3REFBMEI7QUFDMUIsZ0RBQXdCO0FBQ3hCLHNEQUE4QjtBQUU5Qiw0REFBNEI7QUFDNUIsdURBQW9EO0FBQ3BELG9EQUErRDtBQUMvRCwwRUFBdUU7QUFDdkUsMERBQXVEO0FBQ3ZELDRFQUF5RTtBQUN6RSw4RUFBMkU7QUFFM0Usc0RBQW1EO0FBQ25ELGtFQUErRDtBQUMvRCx3RUFBcUU7QUFHOUQsS0FBSyxVQUFVLEtBQUssQ0FBQyxFQUMxQixHQUFHLEdBQUcsaUJBQU8sQ0FBQyxHQUFHLEVBQUUsRUFDbkIsVUFBVSxHQUFHLEtBQUssRUFDbEIsTUFBTSxHQUFHLEtBQUssRUFDZCxpQkFBaUIsR0FBRyxLQUFLLEVBQ3pCLElBQUksR0FBRyxjQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxjQUFjLENBQUMsRUFDeEMsUUFBUSxHQUFHLGVBQWUsRUFDMUIsS0FBSyxFQUNMLEdBQUcsR0FBRyxrQkFBa0IsRUFDeEIsb0JBQW9CLEVBQ3BCLHFCQUFxQixFQUNyQix3QkFBd0IsRUFDeEIsc0JBQXNCLEVBQ3RCLFNBQVMsR0FBRywyQkFBbUIsR0FDbkI7O0lBQ1osZ0RBQWdEO0lBQ2hELFVBQVU7SUFDVixnREFBZ0Q7SUFDaEQsSUFBSSxHQUFHLEtBQUssU0FBUyxFQUFFO1FBQ3JCLGlCQUFPLENBQUMsR0FBRyxDQUFDLGFBQWEsR0FBRyxTQUFTLENBQUM7S0FDdkM7SUFFRCxnREFBZ0Q7SUFDaEQsT0FBTztJQUNQLCtDQUErQztJQUMvQyxnREFBZ0Q7SUFDaEQsTUFBTSxnQkFBZ0IsR0FBNkIsTUFB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ZSB9IGZyb20gJ0Bzc2VuL2J1bmRsZS1pbXBvcnQtcmV3cml0ZSc7XG5pbXBvcnQge1xuICBjb2xsZWN0RGVwZW5kZW5jaWVzLFxuICBjb2xsZWN0U2NyaXB0cyxcbiAgZ2V0UGFja2FnZXNPcmRlcixcbn0gZnJvbSAnQHNzZW4vY29sbGVjdC1kZXBlbmRlbmNpZXMnO1xuaW1wb3J0IHsgY3JlYXRlRXh0ZW5kZWRDb21waWxlckhvc3QgfSBmcm9tICdAc3Nlbi9leHRlbmRlZC1jb21waWxlci1ob3N0JztcbmltcG9ydCB7IGZsYXRQYWNrYWdlTmFtZSB9IGZyb20gJ0Bzc2VuL2ZsYXQtcGFja2FnZS1uYW1lJztcbmltcG9ydCB7IGNyZWF0ZUltcG9ydFBhdGhSZXdyaXRlQ29tcGlsZXJIb3N0IH0gZnJvbSAnQHNzZW4vaW1wb3J0LXBhdGgtcmV3cml0ZS1jb21waWxlci1ob3N0JztcbmltcG9ydCB7IHJpbXJhZiB9IGZyb20gJ0Bzc2VuL3Byb21pc2VkJztcbmltcG9ydCB7IHJld3JpdGVTcmNQYXRoIH0gZnJvbSAnQHNzZW4vcmV3cml0ZS1zcmMtcGF0aCc7XG5pbXBvcnQgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgcHJvY2VzcyBmcm9tICdwcm9jZXNzJztcbmltcG9ydCB7IFBhY2thZ2VKc29uIH0gZnJvbSAndHlwZS1mZXN0JztcbmltcG9ydCB0cyBmcm9tICd0eXBlc2NyaXB0JztcbmltcG9ydCB7IHJlYWRQYWNrYWdlcyB9IGZyb20gJy4vZW50cnkvcmVhZFBhY2thZ2VzJztcbmltcG9ydCB7IGJ1aWxkTWVzc2FnZUhhbmRsZXIgfSBmcm9tICcuL21lc3NhZ2UtaGFuZGxlcnMvYnVpbGQnO1xuaW1wb3J0IHsgY29tcHV0ZVBhY2thZ2VKc29uIH0gZnJvbSAnLi9wYWNrYWdlLWpzb24vY29tcHV0ZVBhY2thZ2VKc29uJztcbmltcG9ydCB7IGdldEV4cG9ydHMgfSBmcm9tICcuL3BhY2thZ2UtanNvbi9nZXRFeHBvcnRzJztcbmltcG9ydCB7IGdldFJvb3REZXBlbmRlbmNpZXMgfSBmcm9tICcuL3BhY2thZ2UtanNvbi9nZXRSb290RGVwZW5kZW5jaWVzJztcbmltcG9ydCB7IGdldFNoYXJlZFBhY2thZ2VKc29uIH0gZnJvbSAnLi9wYWNrYWdlLWpzb24vZ2V0U2hhcmVkUGFja2FnZUpzb24nO1xuaW1wb3J0IHsgQnVpbGRQYXJhbXMgfSBmcm9tICcuL3BhcmFtcyc7XG5pbXBvcnQgeyBmc0NvcHlGaWx0ZXIgfSBmcm9tICcuL3J1bGUvZnNDb3B5RmlsdGVyJztcbmltcG9ydCB7IGdldENvbXBpbGVyT3B0aW9ucyB9IGZyb20gJy4vcnVsZS9nZXRDb21waWxlck9wdGlvbnMnO1xuaW1wb3J0IHsgcmVhZERpcmVjdG9yeVBhdHRlcm5zIH0gZnJvbSAnLi9ydWxlL3JlYWREaXJlY3RvcnlQYXR0ZXJucyc7XG5pbXBvcnQgeyBQYWNrYWdlSW5mbyB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYnVpbGQoe1xuICBjd2QgPSBwcm9jZXNzLmN3ZCgpLFxuICBzb3VyY2VSb290ID0gJ3NyYycsXG4gIHN0cmljdCA9IGZhbHNlLFxuICBzaG93UGFja2FnZXNPcmRlciA9IGZhbHNlLFxuICBkaXN0ID0gcGF0aC5yZXNvbHZlKGN3ZCwgJ291dC9wYWNrYWdlcycpLFxuICB0c2NvbmZpZyA9ICd0c2NvbmZpZy5qc29uJyxcbiAgZW50cnksXG4gIHN2ZyA9ICdjcmVhdGUtcmVhY3QtYXBwJyxcbiAgdHJhbnNmb3JtUGFja2FnZUpzb24sXG4gIHRyYW5zZm9ybUNvbXBpbGVySG9zdCxcbiAgdHJhbnNmb3JtQ29tcGlsZXJPcHRpb25zLFxuICBlbWl0Q3VzdG9tVHJhbnNmb3JtZXJzLFxuICBvbk1lc3NhZ2UgPSBidWlsZE1lc3NhZ2VIYW5kbGVyLFxufTogQnVpbGRQYXJhbXMpIHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHNldCBlbnZcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGlmIChzdmcgPT09ICdkZWZhdWx0Jykge1xuICAgIHByb2Nlc3MuZW52LlRTX1NWR19FWFBPUlQgPSAnZGVmYXVsdCc7XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gcnVsZVxuICAvLyBjb2xsZWN0IGluZm9ybWF0aW9uIGJhc2VkIG9uIGRpcmVjdG9yeSBydWxlc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgY29uc3QgaW50ZXJuYWxQYWNrYWdlczogTWFwPHN0cmluZywgUGFja2FnZUluZm8+ID0gYXdhaXQgcmVhZFBhY2thZ2VzKHtcbiAgICBjd2QsXG4gICAgc291cmNlUm9vdCxcbiAgICBlbnRyeSxcbiAgfSk7XG4gIGNvbnN0IGV4dGVybmFsUGFja2FnZXM6IFBhY2thZ2VKc29uLkRlcGVuZGVuY3kgPSBhd2FpdCBnZXRSb290RGVwZW5kZW5jaWVzKHtcbiAgICBjd2QsXG4gIH0pO1xuICBjb25zdCBzaGFyZWRDb25maWc6IFBhY2thZ2VKc29uID0gYXdhaXQgZ2V0U2hhcmVkUGFja2FnZUpzb24oeyBjd2QgfSk7XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIGVudHJ5XG4gIC8vIGNyZWF0ZSBidWlsZCBvcHRpb25zIGJhc2VkIG9uIHJ1bGUgb3V0cHV0XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBjb25zdCBkZXBlbmRlbmNpZXNNYXA6IE1hcDxzdHJpbmcsIFBhY2thZ2VKc29uLkRlcGVuZGVuY3k+ID0gbmV3IE1hcDxcbiAgICBzdHJpbmcsXG4gICAgUGFja2FnZUpzb24uRGVwZW5kZW5jeVxuICA+KCk7XG5cbiAgLy8gY29sbGVjdCBkZXBlbmRlbmNpZXMgZWFjaCBwYWNrYWdlXG4gIGZvciAoY29uc3QgcGFja2FnZU5hbWUgb2YgaW50ZXJuYWxQYWNrYWdlcy5rZXlzKCkpIHtcbiAgICBjb25zdCBpbXBvcnRzOiBQYWNrYWdlSnNvbi5EZXBlbmRlbmN5ID0gYXdhaXQgY29sbGVjdERlcGVuZGVuY2llcyh7XG4gICAgICAvLyBjb2xsZWN0IGRlcGVuZGVuY2llcyBmcm9tIHNvdXJjZXMgb24ge2N3ZH0vc3JjL3twYWNrYWdlfVxuICAgICAgcm9vdERpcjogcGF0aC5yZXNvbHZlKGN3ZCwgc291cmNlUm9vdCwgcGFja2FnZU5hbWUpLFxuICAgICAgaW50ZXJuYWxQYWNrYWdlczogaW50ZXJuYWxQYWNrYWdlcyxcbiAgICAgIGV4dGVybmFsUGFja2FnZXMsXG4gICAgICBzZWxmTmFtZXM6IG5ldyBTZXQ8c3RyaW5nPihbcGFja2FnZU5hbWVdKSxcbiAgICAgIGNoZWNrVW5kZWZpbmVkUGFja2FnZTogJ2Vycm9yJyxcbiAgICAgIGZpeEltcG9ydFBhdGg6ICh7IGltcG9ydFBhdGgsIGZpbGVQYXRoIH0pID0+XG4gICAgICAgIHJld3JpdGVTcmNQYXRoKHtcbiAgICAgICAgICByb290RGlyOiBwYXRoLnJlc29sdmUoY3dkLCBzb3VyY2VSb290KSxcbiAgICAgICAgICBpbXBvcnRQYXRoLFxuICAgICAgICAgIGZpbGVQYXRoLFxuICAgICAgICB9KSxcbiAgICAgIC4uLmNvbGxlY3RTY3JpcHRzLFxuICAgIH0pO1xuXG4gICAgZGVwZW5kZW5jaWVzTWFwLnNldChwYWNrYWdlTmFtZSwgaW1wb3J0cyk7XG4gIH1cblxuICBjb25zdCBwYWNrYWdlSnNvbk1hcDogTWFwPHN0cmluZywgUGFja2FnZUpzb24+ID0gbmV3IE1hcDxcbiAgICBzdHJpbmcsXG4gICAgUGFja2FnZUpzb25cbiAgPigpO1xuXG4gIC8vIGNvbXB1dGUgcGFja2FnZS5qc29uIGNvbnRlbnRzIGVhY2ggcGFja2FnZVxuICBmb3IgKGNvbnN0IFtwYWNrYWdlTmFtZSwgcGFja2FnZUluZm9dIG9mIGludGVybmFsUGFja2FnZXMpIHtcbiAgICBjb25zdCBkZXBlbmRlbmNpZXM6IFBhY2thZ2VKc29uLkRlcGVuZGVuY3kgfCB1bmRlZmluZWQgPVxuICAgICAgZGVwZW5kZW5jaWVzTWFwLmdldChwYWNrYWdlTmFtZSk7XG5cbiAgICBpZiAoIWRlcGVuZGVuY2llcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmRlZmllbmQgZGVwZW5kZW5jaWVzIG9mICR7cGFja2FnZU5hbWV9YCk7XG4gICAgfVxuXG4gICAgLy9jb25zdCBwYWNrYWdlRGlyOiBzdHJpbmcgPSBwYXRoLnJlc29sdmUoY3dkLCBzb3VyY2VSb290LCBwYWNrYWdlTmFtZSk7XG5cbiAgICAvLyBjb21wdXRlIHBhY2thZ2UuanNvblxuICAgIGNvbnN0IGNvbXB1dGVkUGFja2FnZUpzb246IFBhY2thZ2VKc29uID0gYXdhaXQgY29tcHV0ZVBhY2thZ2VKc29uKHtcbiAgICAgIHBhY2thZ2VJbmZvLFxuICAgICAgc2hhcmVkQ29uZmlnLFxuICAgICAgZGVwZW5kZW5jaWVzLFxuICAgIH0pO1xuXG4gICAgLy8gdHJhbnNmb3JtIHBhY2thZ2UuanNvbiBjb250ZW50cyBpZiB1c2VyIGRpZCBzZXQgdGhlIHRyYW5zZm9ybVBhY2thZ2VKc29uKCkgZnVuY3Rpb25cbiAgICBjb25zdCBwYWNrYWdlSnNvbjogUGFja2FnZUpzb24gPVxuICAgICAgdHlwZW9mIHRyYW5zZm9ybVBhY2thZ2VKc29uID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gdHJhbnNmb3JtUGFja2FnZUpzb24ocGFja2FnZU5hbWUpKGNvbXB1dGVkUGFja2FnZUpzb24pXG4gICAgICAgIDogY29tcHV0ZWRQYWNrYWdlSnNvbjtcblxuICAgIHBhY2thZ2VKc29uTWFwLnNldChwYWNrYWdlTmFtZSwgcGFja2FnZUpzb24pO1xuICB9XG5cbiAgLy8gZ2V0IHBhY2thZ2UgYnVpbGQgb3JkZXJcbiAgLy8gaXQgd2lsbCBzb3J0IGRlcGVuZHMgb24gcGFja2FnZXMgZGVwZW5kZW5jeSByZWxhdGlvbnNoaXBcbiAgY29uc3QgcGFja2FnZXNPcmRlciA9IGF3YWl0IGdldFBhY2thZ2VzT3JkZXIoe1xuICAgIHBhY2thZ2VKc29uQ29udGVudHM6IEFycmF5LmZyb20ocGFja2FnZUpzb25NYXAudmFsdWVzKCkpLFxuICB9KTtcblxuICBjb25zdCBvcmRlcjogc3RyaW5nW10gPSBwYWNrYWdlc09yZGVyLm1hcCgoeyBuYW1lIH0pID0+IG5hbWUpO1xuXG4gIGlmIChzaG93UGFja2FnZXNPcmRlcikge1xuICAgIGNvbnNvbGUubG9nKCdwYWNrYWdlcyBvcmRlcjonLCBvcmRlci5qb2luKCcsICcpKTtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUoXG4gICAgICBwYXRoLmpvaW4oZGlzdCwgJ3BhY2thZ2VKc29uTWFwLmpzb24nKSxcbiAgICAgIEpTT04uc3RyaW5naWZ5KEFycmF5LmZyb20ocGFja2FnZUpzb25NYXAudmFsdWVzKCkpLCBudWxsLCAyKSxcbiAgICApO1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgYHBhY2thZ2VKc29uIGZpbGVzIHNhdmVkIGluIFwiJHtwYXRoLmpvaW4oZGlzdCwgJ3BhY2thZ2VKc29uTWFwLmpzb24nKX1cImAsXG4gICAgKTtcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBydW5cbiAgLy8gYnVpbGQgcGFja2FnZXNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGNvbnN0IHN5bWxpbmtEaXJzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gYnVpbGQgZWFjaCBwYWNrYWdlc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGZvciAoY29uc3QgcGFja2FnZU5hbWUgb2Ygb3JkZXIpIHtcbiAgICBjb25zdCBwYWNrYWdlSW5mbzogUGFja2FnZUluZm8gfCB1bmRlZmluZWQgPVxuICAgICAgaW50ZXJuYWxQYWNrYWdlcy5nZXQocGFja2FnZU5hbWUpO1xuXG4gICAgaWYgKCFwYWNrYWdlSW5mbykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmRlZmluZWQgcGFja2FnZUluZm8gb2YgJHtwYWNrYWdlTmFtZX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBzb3VyY2VEaXI6IHN0cmluZyA9IHBhdGgucmVzb2x2ZShjd2QsIHNvdXJjZVJvb3QsIHBhY2thZ2VOYW1lKTtcbiAgICBjb25zdCBvdXREaXI6IHN0cmluZyA9IHBhdGgucmVzb2x2ZShkaXN0LCBmbGF0UGFja2FnZU5hbWUocGFja2FnZU5hbWUpKTtcbiAgICBjb25zdCBwYWNrYWdlSnNvbjogUGFja2FnZUpzb24gfCB1bmRlZmluZWQgPVxuICAgICAgcGFja2FnZUpzb25NYXAuZ2V0KHBhY2thZ2VOYW1lKTtcblxuICAgIGlmICghcGFja2FnZUpzb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5kZWZpbmVkIHBhY2thZ2Vqc29uIGNvbnRlbnQhYCk7XG4gICAgfVxuXG4gICAgYXdhaXQgb25NZXNzYWdlKHtcbiAgICAgIHR5cGU6ICdiZWdpbicsXG4gICAgICBwYWNrYWdlTmFtZSxcbiAgICAgIHNvdXJjZURpcixcbiAgICAgIG91dERpcixcbiAgICB9KTtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGNsZWFuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYXdhaXQgcmltcmFmKG91dERpcik7XG5cbiAgICBhd2FpdCBmcy5ta2RpcnAob3V0RGlyKTtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHN5bWxpbmtcbiAgICAvLyB0aGlzIHN5bWxpbmsgd2lsbCBiZSByZWZlcmVuY2UgdG8gbmV4dCBidWlsZCBwYWNrYWdlc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGNvbnN0IHN5bWxpbms6IHN0cmluZyA9IHBhdGgucmVzb2x2ZShjd2QsICdub2RlX21vZHVsZXMnLCBwYWNrYWdlTmFtZSk7XG5cbiAgICBpZiAoZnMuZXhpc3RzU3luYyhzeW1saW5rKSAmJiBmcy5sc3RhdFN5bmMoc3ltbGluaykuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgZnMudW5saW5rU3luYyhzeW1saW5rKTtcbiAgICB9XG5cbiAgICBhd2FpdCBmcy5ta2RpcnAocGF0aC5kaXJuYW1lKHN5bWxpbmspKTtcblxuICAgIGF3YWl0IGZzLnN5bWxpbmsob3V0RGlyLCBzeW1saW5rKTtcblxuICAgIHN5bWxpbmtEaXJzLnB1c2goc3ltbGluayk7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyB0c2NcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBjb25zdCBidWlsZFR5cGVzOiAoJ21vZHVsZScgfCAnY29tbW9uanMnKVtdID0gW107XG5cbiAgICBpZiAocGFja2FnZUluZm8uZXhwb3J0cy5tb2R1bGUpIGJ1aWxkVHlwZXMucHVzaCgnbW9kdWxlJyk7XG4gICAgaWYgKHBhY2thZ2VJbmZvLmV4cG9ydHMuY29tbW9uanMpIGJ1aWxkVHlwZXMucHVzaCgnY29tbW9uanMnKTtcblxuICAgIGZvciAoY29uc3QgYnVpbGRUeXBlIG9mIGJ1aWxkVHlwZXMpIHtcbiAgICAgIGNvbnN0IGlzTWFpbkJ1aWxkID0gYnVpbGRUeXBlID09PSBwYWNrYWdlSW5mby5leHBvcnRzLm1haW47XG5cbiAgICAgIC8vIHJlYWQgY29tcGlsZXJPcHRpb25zIGZyb20ge2N3ZH0vdHNjb25maWcuanNvblxuICAgICAgY29uc3QgdXNlckNvbXBpbGVyT3B0aW9uczogdHMuQ29tcGlsZXJPcHRpb25zID0gZ2V0Q29tcGlsZXJPcHRpb25zKHtcbiAgICAgICAgc2VhcmNoUGF0aDogY3dkLFxuICAgICAgICBjb25maWdOYW1lOiB0c2NvbmZpZyxcbiAgICAgICAgcGFja2FnZUluZm8sXG4gICAgICAgIGJ1aWxkVHlwZSxcbiAgICAgICAgZGVjbGFyYXRpb246IGlzTWFpbkJ1aWxkLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIGNvbXB1dGUgcGFja2FnZS5qc29uIHdpdGggYWRkIHNvbWUgYnVpbGQgaW5mb3JtYXRpb25cbiAgICAgIGNvbnN0IGNvbXB1dGVkQ29tcGlsZXJPcHRpb25zOiB0cy5Db21waWxlck9wdGlvbnMgPSB7XG4gICAgICAgIC4uLnVzZXJDb21waWxlck9wdGlvbnMsXG5cbiAgICAgICAgYmFzZVVybDogc291cmNlRGlyLFxuICAgICAgICBwYXRoczoge1xuICAgICAgICAgIC4uLnVzZXJDb21waWxlck9wdGlvbnMucGF0aHMsXG4gICAgICAgICAgW3BhY2thZ2VOYW1lXTogWycuJ10sXG4gICAgICAgICAgW3BhY2thZ2VOYW1lICsgJy8qJ106IFsnLi8qJ10sXG4gICAgICAgIH0sXG5cbiAgICAgICAgcm9vdERpcjogc291cmNlRGlyLFxuICAgICAgICBvdXREaXI6IGlzTWFpbkJ1aWxkID8gb3V0RGlyIDogcGF0aC5qb2luKG91dERpciwgYF8ke2J1aWxkVHlwZX1gKSxcbiAgICAgICAgaW5jcmVtZW50YWw6IHRydWUsXG4gICAgICAgIHRzQnVpbGRJbmZvRmlsZTogcGF0aC5qb2luKFxuICAgICAgICAgIGRpc3QsXG4gICAgICAgICAgZmxhdFBhY2thZ2VOYW1lKHBhY2thZ2VOYW1lKSArICcudHNidWlsZGluZm8nLFxuICAgICAgICApLFxuICAgICAgfTtcblxuICAgICAgLy8gdHJhbnNmb3JtIGNvbXBpbGVyT3B0aW9ucyBpZiB1c2VyIHNldCB0aGUgdHJhbnNmb3JtQ29tcGlsZXJPcHRpb25zKCkgZnVuY3Rpb25cbiAgICAgIGNvbnN0IGNvbXBpbGVyT3B0aW9uczogdHMuQ29tcGlsZXJPcHRpb25zID1cbiAgICAgICAgdHlwZW9mIHRyYW5zZm9ybUNvbXBpbGVyT3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgID8gdHJhbnNmb3JtQ29tcGlsZXJPcHRpb25zKHBhY2thZ2VOYW1lKShjb21wdXRlZENvbXBpbGVyT3B0aW9ucylcbiAgICAgICAgICA6IGNvbXB1dGVkQ29tcGlsZXJPcHRpb25zO1xuXG4gICAgICAvLyBjcmVhdGUgY29tcGlsZXJIb3N0XG4gICAgICBjb25zdCBleHRlbmRlZEhvc3Q6IHRzLkNvbXBpbGVySG9zdCA9XG4gICAgICAgIGNyZWF0ZUV4dGVuZGVkQ29tcGlsZXJIb3N0KGNvbXBpbGVyT3B0aW9ucyk7XG5cbiAgICAgIGNvbnN0IHBhdGhSZXdyaXRlSG9zdDogdHMuQ29tcGlsZXJIb3N0ID1cbiAgICAgICAgY3JlYXRlSW1wb3J0UGF0aFJld3JpdGVDb21waWxlckhvc3Qoe1xuICAgICAgICAgIHNyYzogcGF0aC5yZXNvbHZlKGN3ZCwgc291cmNlUm9vdCksXG4gICAgICAgICAgcm9vdERpcjogc291cmNlRGlyLFxuICAgICAgICB9KShjb21waWxlck9wdGlvbnMsIHVuZGVmaW5lZCwgZXh0ZW5kZWRIb3N0KTtcblxuICAgICAgLy8gdHJhbnNmb3JtIGNvbXBpbGVySG9zdCBpZiB1c2VyIHNldCB0aGUgdHJhbnNmb3JtQ29tcGlsZXJIb3N0KCkgZnVuY3Rpb25cbiAgICAgIGNvbnN0IGhvc3Q6IHRzLkNvbXBpbGVySG9zdCA9XG4gICAgICAgIHR5cGVvZiB0cmFuc2Zvcm1Db21waWxlckhvc3QgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICA/IHRyYW5zZm9ybUNvbXBpbGVySG9zdChwYWNrYWdlTmFtZSkoY29tcGlsZXJPcHRpb25zLCBwYXRoUmV3cml0ZUhvc3QpXG4gICAgICAgICAgOiBwYXRoUmV3cml0ZUhvc3Q7XG5cbiAgICAgIGNvbnN0IGZpbGVzOiBzdHJpbmdbXSA9IGhvc3QucmVhZERpcmVjdG9yeSEoXG4gICAgICAgIHNvdXJjZURpcixcbiAgICAgICAgLi4ucmVhZERpcmVjdG9yeVBhdHRlcm5zLFxuICAgICAgKTtcblxuICAgICAgY29uc3QgcHJvZ3JhbTogdHMuUHJvZ3JhbSA9IHRzLmNyZWF0ZVByb2dyYW0oXG4gICAgICAgIGZpbGVzLFxuICAgICAgICBjb21waWxlck9wdGlvbnMsXG4gICAgICAgIGhvc3QsXG4gICAgICApO1xuXG4gICAgICBjb25zdCBjdXN0b21UcmFuc2Zvcm1lcnMgPVxuICAgICAgICB0eXBlb2YgZW1pdEN1c3RvbVRyYW5zZm9ybWVycyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgID8gZW1pdEN1c3RvbVRyYW5zZm9ybWVycyhwYWNrYWdlTmFtZSkoKSA/PyB7fVxuICAgICAgICAgIDoge307XG5cbiAgICAgIGN1c3RvbVRyYW5zZm9ybWVycy5hZnRlciA9IFtcbiAgICAgICAgLi4uKGN1c3RvbVRyYW5zZm9ybWVycy5hZnRlciA/PyBbXSksXG4gICAgICAgIGJ1bmRsZUltcG9ydFJld3JpdGUoe30pLFxuICAgICAgXTtcblxuICAgICAgLy8g8J+UpSBjb21waWxlISEhISEhISEhXG4gICAgICBjb25zdCBlbWl0UmVzdWx0OiB0cy5FbWl0UmVzdWx0ID0gcHJvZ3JhbS5lbWl0KFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIGN1c3RvbVRyYW5zZm9ybWVycyxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGRpYWdub3N0aWNzOiB0cy5EaWFnbm9zdGljW10gPSB0c1xuICAgICAgICAuZ2V0UHJlRW1pdERpYWdub3N0aWNzKHByb2dyYW0pXG4gICAgICAgIC5jb25jYXQoZW1pdFJlc3VsdC5kaWFnbm9zdGljcyk7XG5cbiAgICAgIGF3YWl0IG9uTWVzc2FnZSh7XG4gICAgICAgIHR5cGU6ICd0c2MnLFxuICAgICAgICBwYWNrYWdlTmFtZSxcbiAgICAgICAgY29tcGlsZXJPcHRpb25zLFxuICAgICAgICBkaWFnbm9zdGljcyxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoKHN0cmljdCAmJiBkaWFnbm9zdGljcy5sZW5ndGggPiAwKSB8fCBlbWl0UmVzdWx0LmVtaXRTa2lwcGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQnVpbGQgXCIke3BhY2thZ2VOYW1lfVwiIGlzIGZhaWxlZGApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGNvcHkgc3RhdGljIGZpbGVzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYXdhaXQgZnMuY29weShwYXRoLnJlc29sdmUoY3dkLCBzb3VyY2VSb290LCBwYWNrYWdlTmFtZSksIG91dERpciwge1xuICAgICAgZmlsdGVyOiBmc0NvcHlGaWx0ZXIsXG4gICAgfSk7XG5cbiAgICBwYWNrYWdlSnNvbi5leHBvcnRzID0gYXdhaXQgZ2V0RXhwb3J0cyhwYWNrYWdlSW5mby5leHBvcnRzLCBvdXREaXIpO1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gY3JlYXRlIHBhY2thZ2UuanNvblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGF3YWl0IGZzLndyaXRlSnNvbihwYXRoLnJlc29sdmUob3V0RGlyLCAncGFja2FnZS5qc29uJyksIHBhY2thZ2VKc29uLCB7XG4gICAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgICAgc3BhY2VzOiAyLFxuICAgIH0pO1xuXG4gICAgYXdhaXQgb25NZXNzYWdlKHtcbiAgICAgIHR5cGU6ICdwYWNrYWdlLWpzb24nLFxuICAgICAgcGFja2FnZU5hbWUsXG4gICAgICBwYWNrYWdlSnNvbixcbiAgICB9KTtcblxuICAgIGF3YWl0IG9uTWVzc2FnZSh7XG4gICAgICB0eXBlOiAnc3VjY2VzcycsXG4gICAgICBwYWNrYWdlSnNvbixcbiAgICAgIHBhY2thZ2VOYW1lLFxuICAgICAgc291cmNlRGlyLFxuICAgICAgb3V0RGlyLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gY2xlYW4gc3ltbGlua3Mgb24gbm9kZV9tb2R1bGVzXG4gIGZvciAoY29uc3Qgc3ltbGluayBvZiBzeW1saW5rRGlycykge1xuICAgIGZzLnVubGlua1N5bmMoc3ltbGluayk7XG4gIH1cbn1cbiJdfQ==