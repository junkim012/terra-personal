"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.doctor = void 0;
const read_tsconfig_1 = require("@ssen/read-tsconfig");
const depcheck_1 = __importDefault(require("depcheck"));
const path_1 = __importDefault(require("path"));
const process_1 = __importDefault(require("process"));
const readPackages_1 = require("./entry/readPackages");
const doctor_1 = require("./message-handlers/doctor");
async function doctor({ cwd = process_1.default.cwd(), entry, sourceRoot = 'src', tsconfig = 'tsconfig.json', onMessage = doctor_1.doctorMessageHandler, }) {
    var _a;
    const internalPackages = await readPackages_1.readPackages({
        cwd,
        sourceRoot,
        entry,
    });
    const depcheckResult = await depcheck_1.default(cwd, {
        ignoreMatches: [
            ...Array.from(internalPackages.values()).map(({ name }) => name),
        ],
    });
    await onMessage({
        type: 'depcheck',
        result: depcheckResult,
    });
    const { options } = read_tsconfig_1.readTSConfig(path_1.default.join(cwd, tsconfig));
    const tsconfigResult = [];
    // TODO src to be user configurable
    if (!/src$/.test((_a = options.baseUrl) !== null && _a !== void 0 ? _a : '')) {
        tsconfigResult.push({
            message: `compilerOptions.baseUrl should be "src".`,
            fixer: {
                compilerOptions: {
                    baseUrl: 'src',
                },
            },
        });
    }
    if (tsconfigResult.length > 0) {
        await onMessage({
            type: 'tsconfig',
            result: tsconfigResult,
        });
    }
}
exports.doctor = doctor;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG9jdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3JvY2tldC1wdW5jaC9kb2N0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsdURBQW1EO0FBQ25ELHdEQUFnQztBQUNoQyxnREFBd0I7QUFDeEIsc0RBQThCO0FBQzlCLHVEQUFvRDtBQUNwRCxzREFBaUU7QUFJMUQsS0FBSyxVQUFVLE1BQU0sQ0FBQyxFQUMzQixHQUFHLEdBQUcsaUJBQU8sQ0FBQyxHQUFHLEVBQUUsRUFDbkIsS0FBSyxFQUNMLFVBQVUsR0FBRyxLQUFLLEVBQ2xCLFFBQVEsR0FBRyxlQUFlLEVBQzFCLFNBQVMsR0FBRyw2QkFBb0IsR0FDbkI7O0lBQ2IsTUFBTSxnQkFBZ0IsR0FBNkIsTUFBTSwyQkFBWSxDQUFDO1FBQ3BFLEdBQUc7UUFDSCxVQUFVO1FBQ1YsS0FBSztLQUNOLENBQUMsQ0FBQztJQUVILE1BQU0sY0FBYyxHQUFHLE1BQU0sa0JBQVEsQ0FBQyxHQUFHLEVBQUU7UUFDekMsYUFBYSxFQUFFO1lBQ2IsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDO1NBQ2pFO0tBQ0YsQ0FBQyxDQUFDO0lBRUgsTUFBTSxTQUFTLENBQUM7UUFDZCxJQUFJLEVBQUUsVUFBVTtRQUNoQixNQUFNLEVBQUUsY0FBYztLQUN2QixDQUFDLENBQUM7SUFFSCxNQUFNLEVBQUUsT0FBTyxFQUFFLEdBQUcsNEJBQVksQ0FBQyxjQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQzNELE1BQU0sY0FBYyxHQUF5QyxFQUFFLENBQUM7SUFFaEUsbUNBQW1DO0lBQ25DLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQUEsT0FBTyxDQUFDLE9BQU8sbUNBQUksRUFBRSxDQUFDLEVBQUU7UUFDdkMsY0FBYyxDQUFDLElBQUksQ0FBQztZQUNsQixPQUFPLEVBQUUsMENBQTBDO1lBQ25ELEtBQUssRUFBRTtnQkFDTCxlQUFlLEVBQUU7b0JBQ2YsT0FBTyxFQUFFLEtBQUs7aUJBQ2Y7YUFDRjtTQUNGLENBQUMsQ0FBQztLQUNKO0lBRUQsSUFBSSxjQUFjLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtRQUM3QixNQUFNLFNBQVMsQ0FBQztZQUNkLElBQUksRUFBRSxVQUFVO1lBQ2hCLE1BQU0sRUFBRSxjQUFjO1NBQ3ZCLENBQUMsQ0FBQztLQUNKO0FBQ0gsQ0FBQztBQTdDRCx3QkE2Q0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZWFkVFNDb25maWcgfSBmcm9tICdAc3Nlbi9yZWFkLXRzY29uZmlnJztcbmltcG9ydCBkZXBjaGVjayBmcm9tICdkZXBjaGVjayc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBwcm9jZXNzIGZyb20gJ3Byb2Nlc3MnO1xuaW1wb3J0IHsgcmVhZFBhY2thZ2VzIH0gZnJvbSAnLi9lbnRyeS9yZWFkUGFja2FnZXMnO1xuaW1wb3J0IHsgZG9jdG9yTWVzc2FnZUhhbmRsZXIgfSBmcm9tICcuL21lc3NhZ2UtaGFuZGxlcnMvZG9jdG9yJztcbmltcG9ydCB7IERvY3RvclBhcmFtcyB9IGZyb20gJy4vcGFyYW1zJztcbmltcG9ydCB7IFBhY2thZ2VJbmZvIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkb2N0b3Ioe1xuICBjd2QgPSBwcm9jZXNzLmN3ZCgpLFxuICBlbnRyeSxcbiAgc291cmNlUm9vdCA9ICdzcmMnLFxuICB0c2NvbmZpZyA9ICd0c2NvbmZpZy5qc29uJyxcbiAgb25NZXNzYWdlID0gZG9jdG9yTWVzc2FnZUhhbmRsZXIsXG59OiBEb2N0b3JQYXJhbXMpIHtcbiAgY29uc3QgaW50ZXJuYWxQYWNrYWdlczogTWFwPHN0cmluZywgUGFja2FnZUluZm8+ID0gYXdhaXQgcmVhZFBhY2thZ2VzKHtcbiAgICBjd2QsXG4gICAgc291cmNlUm9vdCxcbiAgICBlbnRyeSxcbiAgfSk7XG5cbiAgY29uc3QgZGVwY2hlY2tSZXN1bHQgPSBhd2FpdCBkZXBjaGVjayhjd2QsIHtcbiAgICBpZ25vcmVNYXRjaGVzOiBbXG4gICAgICAuLi5BcnJheS5mcm9tKGludGVybmFsUGFja2FnZXMudmFsdWVzKCkpLm1hcCgoeyBuYW1lIH0pID0+IG5hbWUpLFxuICAgIF0sXG4gIH0pO1xuXG4gIGF3YWl0IG9uTWVzc2FnZSh7XG4gICAgdHlwZTogJ2RlcGNoZWNrJyxcbiAgICByZXN1bHQ6IGRlcGNoZWNrUmVzdWx0LFxuICB9KTtcblxuICBjb25zdCB7IG9wdGlvbnMgfSA9IHJlYWRUU0NvbmZpZyhwYXRoLmpvaW4oY3dkLCB0c2NvbmZpZykpO1xuICBjb25zdCB0c2NvbmZpZ1Jlc3VsdDogeyBtZXNzYWdlOiBzdHJpbmc7IGZpeGVyOiBvYmplY3QgfVtdID0gW107XG5cbiAgLy8gVE9ETyBzcmMgdG8gYmUgdXNlciBjb25maWd1cmFibGVcbiAgaWYgKCEvc3JjJC8udGVzdChvcHRpb25zLmJhc2VVcmwgPz8gJycpKSB7XG4gICAgdHNjb25maWdSZXN1bHQucHVzaCh7XG4gICAgICBtZXNzYWdlOiBgY29tcGlsZXJPcHRpb25zLmJhc2VVcmwgc2hvdWxkIGJlIFwic3JjXCIuYCxcbiAgICAgIGZpeGVyOiB7XG4gICAgICAgIGNvbXBpbGVyT3B0aW9uczoge1xuICAgICAgICAgIGJhc2VVcmw6ICdzcmMnLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh0c2NvbmZpZ1Jlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgYXdhaXQgb25NZXNzYWdlKHtcbiAgICAgIHR5cGU6ICd0c2NvbmZpZycsXG4gICAgICByZXN1bHQ6IHRzY29uZmlnUmVzdWx0LFxuICAgIH0pO1xuICB9XG59XG4iXX0=