"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCompilerOptions = void 0;
const read_tsconfig_1 = require("@ssen/read-tsconfig");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const typescript_1 = __importDefault(require("typescript"));
function getCompilerOptions({ searchPath, configName, packageInfo, buildType, declaration, }) {
    const { options: tsconfig } = fs_extra_1.default.existsSync(path_1.default.join(searchPath, configName))
        ? read_tsconfig_1.readTSConfig(searchPath, configName)
        : { options: {} };
    const { options: info } = read_tsconfig_1.parseTSConfig(searchPath, {
        compilerOptions: packageInfo.compilerOptions,
    });
    const defaultValues = {
        downlevelIteration: true,
        allowSyntheticDefaultImports: true,
        esModuleInterop: true,
        strict: true,
        resolveJsonModule: true,
        allowJs: true,
        jsx: typescript_1.default.JsxEmit.React,
        target: typescript_1.default.ScriptTarget.ES2018,
    };
    const computed = Object.keys(defaultValues).reduce((result, name) => {
        var _a, _b;
        result[name] = (_b = (_a = info[name]) !== null && _a !== void 0 ? _a : tsconfig[name]) !== null && _b !== void 0 ? _b : defaultValues[name];
        return result;
    }, {});
    return {
        ...computed,
        module: buildType === 'module' ? typescript_1.default.ModuleKind.ES2020 : typescript_1.default.ModuleKind.CommonJS,
        moduleResolution: typescript_1.default.ModuleResolutionKind.NodeJs,
        skipLibCheck: true,
        inlineSources: true,
        inlineSourceMap: true,
        declaration,
    };
}
exports.getCompilerOptions = getCompilerOptions;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2V0Q29tcGlsZXJPcHRpb25zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL3JvY2tldC1wdW5jaC9ydWxlL2dldENvbXBpbGVyT3B0aW9ucy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSx1REFBa0U7QUFDbEUsd0RBQTBCO0FBQzFCLGdEQUF3QjtBQUN4Qiw0REFBNEI7QUFXNUIsU0FBZ0Isa0JBQWtCLENBQUMsRUFDakMsVUFBVSxFQUNWLFVBQVUsRUFDVixXQUFXLEVBQ1gsU0FBUyxFQUNULFdBQVcsR0FDSjtJQUNQLE1BQU0sRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLEdBQUcsa0JBQUUsQ0FBQyxVQUFVLENBQUMsY0FBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFDNUUsQ0FBQyxDQUFDLDRCQUFZLENBQUMsVUFBVSxFQUFFLFVBQVUsQ0FBQztRQUN0QyxDQUFDLENBQUMsRUFBRSxPQUFPLEVBQUUsRUFBd0IsRUFBRSxDQUFDO0lBQzFDLE1BQU0sRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLEdBQUcsNkJBQWEsQ0FBQyxVQUFVLEVBQUU7UUFDbEQsZUFBZSxFQUFFLFdBQVcsQ0FBQyxlQUFlO0tBQzdDLENBQUMsQ0FBQztJQUNILE1BQU0sYUFBYSxHQUFnQztRQUNqRCxrQkFBa0IsRUFBRSxJQUFJO1FBQ3hCLDRCQUE0QixFQUFFLElBQUk7UUFDbEMsZUFBZSxFQUFFLElBQUk7UUFFckIsTUFBTSxFQUFFLElBQUk7UUFFWixpQkFBaUIsRUFBRSxJQUFJO1FBRXZCLE9BQU8sRUFBRSxJQUFJO1FBQ2IsR0FBRyxFQUFFLG9CQUFFLENBQUMsT0FBTyxDQUFDLEtBQUs7UUFFckIsTUFBTSxFQUFFLG9CQUFFLENBQUMsWUFBWSxDQUFDLE1BQU07S0FDdEIsQ0FBQztJQUVYLE1BQU0sUUFBUSxHQUF1QixNQUFNLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLE1BQU0sQ0FDcEUsQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLEVBQUU7O1FBQ2YsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLE1BQUEsTUFBQSxJQUFJLENBQUMsSUFBSSxDQUFDLG1DQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsbUNBQUksYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ25FLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUMsRUFDRCxFQUF3QixDQUN6QixDQUFDO0lBRUYsT0FBTztRQUNMLEdBQUcsUUFBUTtRQUNYLE1BQU0sRUFDSixTQUFTLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxvQkFBRSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLG9CQUFFLENBQUMsVUFBVSxDQUFDLFFBQVE7UUFDeEUsZ0JBQWdCLEVBQUUsb0JBQUUsQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNO1FBQ2hELFlBQVksRUFBRSxJQUFJO1FBQ2xCLGFBQWEsRUFBRSxJQUFJO1FBQ25CLGVBQWUsRUFBRSxJQUFJO1FBQ3JCLFdBQVc7S0FDWixDQUFDO0FBQ0osQ0FBQztBQTlDRCxnREE4Q0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZVRTQ29uZmlnLCByZWFkVFNDb25maWcgfSBmcm9tICdAc3Nlbi9yZWFkLXRzY29uZmlnJztcbmltcG9ydCBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB0cyBmcm9tICd0eXBlc2NyaXB0JztcbmltcG9ydCB7IFBhY2thZ2VJbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbnRlcmZhY2UgUGFyYW1zIHtcbiAgc2VhcmNoUGF0aDogc3RyaW5nO1xuICBjb25maWdOYW1lOiBzdHJpbmc7XG4gIHBhY2thZ2VJbmZvOiBQYWNrYWdlSW5mbztcbiAgYnVpbGRUeXBlOiAnbW9kdWxlJyB8ICdjb21tb25qcyc7XG4gIGRlY2xhcmF0aW9uOiBib29sZWFuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29tcGlsZXJPcHRpb25zKHtcbiAgc2VhcmNoUGF0aCxcbiAgY29uZmlnTmFtZSxcbiAgcGFja2FnZUluZm8sXG4gIGJ1aWxkVHlwZSxcbiAgZGVjbGFyYXRpb24sXG59OiBQYXJhbXMpOiB0cy5Db21waWxlck9wdGlvbnMge1xuICBjb25zdCB7IG9wdGlvbnM6IHRzY29uZmlnIH0gPSBmcy5leGlzdHNTeW5jKHBhdGguam9pbihzZWFyY2hQYXRoLCBjb25maWdOYW1lKSlcbiAgICA/IHJlYWRUU0NvbmZpZyhzZWFyY2hQYXRoLCBjb25maWdOYW1lKVxuICAgIDogeyBvcHRpb25zOiB7fSBhcyB0cy5Db21waWxlck9wdGlvbnMgfTtcbiAgY29uc3QgeyBvcHRpb25zOiBpbmZvIH0gPSBwYXJzZVRTQ29uZmlnKHNlYXJjaFBhdGgsIHtcbiAgICBjb21waWxlck9wdGlvbnM6IHBhY2thZ2VJbmZvLmNvbXBpbGVyT3B0aW9ucyxcbiAgfSk7XG4gIGNvbnN0IGRlZmF1bHRWYWx1ZXM6IFBhcnRpYWw8dHMuQ29tcGlsZXJPcHRpb25zPiA9IHtcbiAgICBkb3dubGV2ZWxJdGVyYXRpb246IHRydWUsXG4gICAgYWxsb3dTeW50aGV0aWNEZWZhdWx0SW1wb3J0czogdHJ1ZSxcbiAgICBlc01vZHVsZUludGVyb3A6IHRydWUsXG5cbiAgICBzdHJpY3Q6IHRydWUsXG5cbiAgICByZXNvbHZlSnNvbk1vZHVsZTogdHJ1ZSxcblxuICAgIGFsbG93SnM6IHRydWUsXG4gICAganN4OiB0cy5Kc3hFbWl0LlJlYWN0LFxuXG4gICAgdGFyZ2V0OiB0cy5TY3JpcHRUYXJnZXQuRVMyMDE4LFxuICB9IGFzIGNvbnN0O1xuXG4gIGNvbnN0IGNvbXB1dGVkOiB0cy5Db21waWxlck9wdGlvbnMgPSBPYmplY3Qua2V5cyhkZWZhdWx0VmFsdWVzKS5yZWR1Y2UoXG4gICAgKHJlc3VsdCwgbmFtZSkgPT4ge1xuICAgICAgcmVzdWx0W25hbWVdID0gaW5mb1tuYW1lXSA/PyB0c2NvbmZpZ1tuYW1lXSA/PyBkZWZhdWx0VmFsdWVzW25hbWVdO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIHt9IGFzIHRzLkNvbXBpbGVyT3B0aW9ucyxcbiAgKTtcblxuICByZXR1cm4ge1xuICAgIC4uLmNvbXB1dGVkLFxuICAgIG1vZHVsZTpcbiAgICAgIGJ1aWxkVHlwZSA9PT0gJ21vZHVsZScgPyB0cy5Nb2R1bGVLaW5kLkVTMjAyMCA6IHRzLk1vZHVsZUtpbmQuQ29tbW9uSlMsXG4gICAgbW9kdWxlUmVzb2x1dGlvbjogdHMuTW9kdWxlUmVzb2x1dGlvbktpbmQuTm9kZUpzLFxuICAgIHNraXBMaWJDaGVjazogdHJ1ZSxcbiAgICBpbmxpbmVTb3VyY2VzOiB0cnVlLFxuICAgIGlubGluZVNvdXJjZU1hcDogdHJ1ZSxcbiAgICBkZWNsYXJhdGlvbixcbiAgfTtcbn1cbiJdfQ==