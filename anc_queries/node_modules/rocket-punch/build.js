import { bundleImportRewrite } from '@ssen/bundle-import-rewrite';
import { collectDependencies, collectScripts, getPackagesOrder, } from '@ssen/collect-dependencies';
import { createExtendedCompilerHost } from '@ssen/extended-compiler-host';
import { flatPackageName } from '@ssen/flat-package-name';
import { createImportPathRewriteCompilerHost } from '@ssen/import-path-rewrite-compiler-host';
import { rimraf } from '@ssen/promised';
import { rewriteSrcPath } from '@ssen/rewrite-src-path';
import fs from 'fs-extra';
import path from 'path';
import process from 'process';
import ts from 'typescript';
import { readPackages } from './entry/readPackages';
import { buildMessageHandler } from './message-handlers/build';
import { computePackageJson } from './package-json/computePackageJson';
import { getExports } from './package-json/getExports';
import { getRootDependencies } from './package-json/getRootDependencies';
import { getSharedPackageJson } from './package-json/getSharedPackageJson';
import { fsCopyFilter } from './rule/fsCopyFilter';
import { getCompilerOptions } from './rule/getCompilerOptions';
import { readDirectoryPatterns } from './rule/readDirectoryPatterns';
export async function build({ cwd = process.cwd(), sourceRoot = 'src', strict = false, showPackagesOrder = false, dist = path.resolve(cwd, 'out/packages'), tsconfig = 'tsconfig.json', entry, svg = 'create-react-app', transformPackageJson, transformCompilerHost, transformCompilerOptions, emitCustomTransformers, onMessage = buildMessageHandler, }) {
    var _a, _b;
    // ---------------------------------------------
    // set env
    // ---------------------------------------------
    if (svg === 'default') {
        process.env.TS_SVG_EXPORT = 'default';
    }
    // ---------------------------------------------
    // rule
    // collect information based on directory rules
    // ---------------------------------------------
    const internalPackages = await readPackages({
        cwd,
        sourceRoot,
        entry,
    });
    const externalPackages = await getRootDependencies({
        cwd,
    });
    const sharedConfig = await getSharedPackageJson({ cwd });
    // ---------------------------------------------
    // entry
    // create build options based on rule output
    // ---------------------------------------------
    const dependenciesMap = new Map();
    // collect dependencies each package
    for (const packageName of internalPackages.keys()) {
        const imports = await collectDependencies({
            // collect dependencies from sources on {cwd}/src/{package}
            rootDir: path.resolve(cwd, sourceRoot, packageName),
            internalPackages: internalPackages,
            externalPackages,
            selfNames: new Set([packageName]),
            checkUndefinedPackage: 'error',
            fixImportPath: ({ importPath, filePath }) => rewriteSrcPath({
                rootDir: path.resolve(cwd, sourceRoot),
                importPath,
                filePath,
            }),
            ...collectScripts,
        });
        dependenciesMap.set(packageName, imports);
    }
    const packageJsonMap = new Map();
    // compute package.json contents each package
    for (const [packageName, packageInfo] of internalPackages) {
        const dependencies = dependenciesMap.get(packageName);
        if (!dependencies) {
            throw new Error(`undefiend dependencies of ${packageName}`);
        }
        //const packageDir: string = path.resolve(cwd, sourceRoot, packageName);
        // compute package.json
        const computedPackageJson = await computePackageJson({
            packageInfo,
            sharedConfig,
            dependencies,
        });
        // transform package.json contents if user did set the transformPackageJson() function
        const packageJson = typeof transformPackageJson === 'function'
            ? transformPackageJson(packageName)(computedPackageJson)
            : computedPackageJson;
        packageJsonMap.set(packageName, packageJson);
    }
    // get package build order
    // it will sort depends on packages dependency relationship
    const packagesOrder = await getPackagesOrder({
        packageJsonContents: Array.from(packageJsonMap.values()),
    });
    const order = packagesOrder.map(({ name }) => name);
    if (showPackagesOrder) {
        console.log('packages order:', order.join(', '));
        await fs.writeFile(path.join(dist, 'packageJsonMap.json'), JSON.stringify(Array.from(packageJsonMap.values()), null, 2));
        console.log(`packageJson files saved in "${path.join(dist, 'packageJsonMap.json')}"`);
    }
    // ---------------------------------------------
    // run
    // build packages
    // ---------------------------------------------
    const symlinkDirs = [];
    // ================================================================
    // build each packages
    // ================================================================
    for (const packageName of order) {
        const packageInfo = internalPackages.get(packageName);
        if (!packageInfo) {
            throw new Error(`Undefined packageInfo of ${packageName}`);
        }
        const sourceDir = path.resolve(cwd, sourceRoot, packageName);
        const outDir = path.resolve(dist, flatPackageName(packageName));
        const packageJson = packageJsonMap.get(packageName);
        if (!packageJson) {
            throw new Error(`undefined packagejson content!`);
        }
        await onMessage({
            type: 'begin',
            packageName,
            sourceDir,
            outDir,
        });
        // ---------------------------------------------
        // clean
        // ---------------------------------------------
        await rimraf(outDir);
        await fs.mkdirp(outDir);
        // ---------------------------------------------
        // symlink
        // this symlink will be reference to next build packages
        // ---------------------------------------------
        const symlink = path.resolve(cwd, 'node_modules', packageName);
        if (fs.existsSync(symlink) && fs.lstatSync(symlink).isSymbolicLink()) {
            fs.unlinkSync(symlink);
        }
        await fs.mkdirp(path.dirname(symlink));
        await fs.symlink(outDir, symlink);
        symlinkDirs.push(symlink);
        // ---------------------------------------------
        // tsc
        // ---------------------------------------------
        const buildTypes = [];
        if (packageInfo.exports.module)
            buildTypes.push('module');
        if (packageInfo.exports.commonjs)
            buildTypes.push('commonjs');
        for (const buildType of buildTypes) {
            const isMainBuild = buildType === packageInfo.exports.main;
            // read compilerOptions from {cwd}/tsconfig.json
            const userCompilerOptions = getCompilerOptions({
                searchPath: cwd,
                configName: tsconfig,
                packageInfo,
                buildType,
                declaration: isMainBuild,
            });
            // compute package.json with add some build information
            const computedCompilerOptions = {
                ...userCompilerOptions,
                baseUrl: sourceDir,
                paths: {
                    ...userCompilerOptions.paths,
                    [packageName]: ['.'],
                    [packageName + '/*']: ['./*'],
                },
                rootDir: sourceDir,
                outDir: isMainBuild ? outDir : path.join(outDir, `_${buildType}`),
                incremental: true,
                tsBuildInfoFile: path.join(dist, flatPackageName(packageName) + '.tsbuildinfo'),
            };
            // transform compilerOptions if user set the transformCompilerOptions() function
            const compilerOptions = typeof transformCompilerOptions === 'function'
                ? transformCompilerOptions(packageName)(computedCompilerOptions)
                : computedCompilerOptions;
            // create compilerHost
            const extendedHost = createExtendedCompilerHost(compilerOptions);
            const pathRewriteHost = createImportPathRewriteCompilerHost({
                src: path.resolve(cwd, sourceRoot),
                rootDir: sourceDir,
            })(compilerOptions, undefined, extendedHost);
            // transform compilerHost if user set the transformCompilerHost() function
            const host = typeof transformCompilerHost === 'function'
                ? transformCompilerHost(packageName)(compilerOptions, pathRewriteHost)
                : pathRewriteHost;
            const files = host.readDirectory(sourceDir, ...readDirectoryPatterns);
            const program = ts.createProgram(files, compilerOptions, host);
            const customTransformers = typeof emitCustomTransformers === 'function'
                ? (_a = emitCustomTransformers(packageName)()) !== null && _a !== void 0 ? _a : {}
                : {};
            customTransformers.after = [
                ...((_b = customTransformers.after) !== null && _b !== void 0 ? _b : []),
                bundleImportRewrite({}),
            ];
            // ðŸ”¥ compile!!!!!!!!!
            const emitResult = program.emit(undefined, undefined, undefined, undefined, customTransformers);
            const diagnostics = ts
                .getPreEmitDiagnostics(program)
                .concat(emitResult.diagnostics);
            await onMessage({
                type: 'tsc',
                packageName,
                compilerOptions,
                diagnostics,
            });
            if ((strict && diagnostics.length > 0) || emitResult.emitSkipped) {
                throw new Error(`Build "${packageName}" is failed`);
            }
        }
        // ---------------------------------------------
        // copy static files
        // ---------------------------------------------
        await fs.copy(path.resolve(cwd, sourceRoot, packageName), outDir, {
            filter: fsCopyFilter,
        });
        packageJson.exports = await getExports(packageInfo.exports, outDir);
        // ---------------------------------------------
        // create package.json
        // ---------------------------------------------
        await fs.writeJson(path.resolve(outDir, 'package.json'), packageJson, {
            encoding: 'utf8',
            spaces: 2,
        });
        await onMessage({
            type: 'package-json',
            packageName,
            packageJson,
        });
        await onMessage({
            type: 'success',
            packageJson,
            packageName,
            sourceDir,
            outDir,
        });
    }
    // clean symlinks on node_modules
    for (const symlink of symlinkDirs) {
        fs.unlinkSync(symlink);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVpbGQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcm9ja2V0LXB1bmNoL2J1aWxkLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQ2xFLE9BQU8sRUFDTCxtQkFBbUIsRUFDbkIsY0FBYyxFQUNkLGdCQUFnQixHQUNqQixNQUFNLDRCQUE0QixDQUFDO0FBQ3BDLE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBQzFFLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUMxRCxPQUFPLEVBQUUsbUNBQW1DLEVBQUUsTUFBTSx5Q0FBeUMsQ0FBQztBQUM5RixPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEMsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3hELE9BQU8sRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUMxQixPQUFPLElBQUksTUFBTSxNQUFNLENBQUM7QUFDeEIsT0FBTyxPQUFPLE1BQU0sU0FBUyxDQUFDO0FBRTlCLE9BQU8sRUFBRSxNQUFNLFlBQVksQ0FBQztBQUM1QixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDcEQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDL0QsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFDdkUsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLG9DQUFvQyxDQUFDO0FBQ3pFLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLHFDQUFxQyxDQUFDO0FBRTNFLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUNuRCxPQUFPLEVBQUUs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RyxNQUFNLFVBQVUsQ0FBQyxXQUFXLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBRXBFLGdEQUFnRDtRQUNoRCxzQkFBc0I7UUFDdEIsZ0RBQWdEO1FBQ2hELE1BQU0sRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxjQUFjLENBQUMsRUFBRSxXQUFXLEVBQUU7WUFDcEUsUUFBUSxFQUFFLE1BQU07WUFDaEIsTUFBTSxFQUFFLENBQUM7U0FDVixDQUFDLENBQUM7UUFFSCxNQUFNLFNBQVMsQ0FBQztZQUNkLElBQUksRUFBRSxjQUFjO1lBQ3BCLFdBQVc7WUFDWCxXQUFXO1NBQ1osQ0FBQyxDQUFDO1FBRUgsTUFBTSxTQUFTLENBQUM7WUFDZCxJQUFJLEVBQUUsU0FBUztZQUNmLFdBQVc7WUFDWCxXQUFXO1lBQ1gsU0FBUztZQUNULE1BQU07U0FDUCxDQUFDLENBQUM7S0FDSjtJQUVELGlDQUFpQztJQUNqQyxLQUFLLE1BQU0sT0FBTyxJQUFJLFdBQVcsRUFBRTtRQUNqQyxFQUFFLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0tBQ3hCO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGJ1bmRsZUltcG9ydFJld3JpdGUgfSBmcm9tICdAc3Nlbi9idW5kbGUtaW1wb3J0LXJld3JpdGUnO1xuaW1wb3J0IHtcbiAgY29sbGVjdERlcGVuZGVuY2llcyxcbiAgY29sbGVjdFNjcmlwdHMsXG4gIGdldFBhY2thZ2VzT3JkZXIsXG59IGZyb20gJ0Bzc2VuL2NvbGxlY3QtZGVwZW5kZW5jaWVzJztcbmltcG9ydCB7IGNyZWF0ZUV4dGVuZGVkQ29tcGlsZXJIb3N0IH0gZnJvbSAnQHNzZW4vZXh0ZW5kZWQtY29tcGlsZXItaG9zdCc7XG5pbXBvcnQgeyBmbGF0UGFja2FnZU5hbWUgfSBmcm9tICdAc3Nlbi9mbGF0LXBhY2thZ2UtbmFtZSc7XG5pbXBvcnQgeyBjcmVhdGVJbXBvcnRQYXRoUmV3cml0ZUNvbXBpbGVySG9zdCB9IGZyb20gJ0Bzc2VuL2ltcG9ydC1wYXRoLXJld3JpdGUtY29tcGlsZXItaG9zdCc7XG5pbXBvcnQgeyByaW1yYWYgfSBmcm9tICdAc3Nlbi9wcm9taXNlZCc7XG5pbXBvcnQgeyByZXdyaXRlU3JjUGF0aCB9IGZyb20gJ0Bzc2VuL3Jld3JpdGUtc3JjLXBhdGgnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHByb2Nlc3MgZnJvbSAncHJvY2Vzcyc7XG5pbXBvcnQgeyBQYWNrYWdlSnNvbiB9IGZyb20gJ3R5cGUtZmVzdCc7XG5pbXBvcnQgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5pbXBvcnQgeyByZWFkUGFja2FnZXMgfSBmcm9tICcuL2VudHJ5L3JlYWRQYWNrYWdlcyc7XG5pbXBvcnQgeyBidWlsZE1lc3NhZ2VIYW5kbGVyIH0gZnJvbSAnLi9tZXNzYWdlLWhhbmRsZXJzL2J1aWxkJztcbmltcG9ydCB7IGNvbXB1dGVQYWNrYWdlSnNvbiB9IGZyb20gJy4vcGFja2FnZS1qc29uL2NvbXB1dGVQYWNrYWdlSnNvbic7XG5pbXBvcnQgeyBnZXRFeHBvcnRzIH0gZnJvbSAnLi9wYWNrYWdlLWpzb24vZ2V0RXhwb3J0cyc7XG5pbXBvcnQgeyBnZXRSb290RGVwZW5kZW5jaWVzIH0gZnJvbSAnLi9wYWNrYWdlLWpzb24vZ2V0Um9vdERlcGVuZGVuY2llcyc7XG5pbXBvcnQgeyBnZXRTaGFyZWRQYWNrYWdlSnNvbiB9IGZyb20gJy4vcGFja2FnZS1qc29uL2dldFNoYXJlZFBhY2thZ2VKc29uJztcbmltcG9ydCB7IEJ1aWxkUGFyYW1zIH0gZnJvbSAnLi9wYXJhbXMnO1xuaW1wb3J0IHsgZnNDb3B5RmlsdGVyIH0gZnJvbSAnLi9ydWxlL2ZzQ29weUZpbHRlcic7XG5pbXBvcnQgeyBnZXRDb21waWxlck9wdGlvbnMgfSBmcm9tICcuL3J1bGUvZ2V0Q29tcGlsZXJPcHRpb25zJztcbmltcG9ydCB7IHJlYWREaXJlY3RvcnlQYXR0ZXJucyB9IGZyb20gJy4vcnVsZS9yZWFkRGlyZWN0b3J5UGF0dGVybnMnO1xuaW1wb3J0IHsgUGFja2FnZUluZm8gfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJ1aWxkKHtcbiAgY3dkID0gcHJvY2Vzcy5jd2QoKSxcbiAgc291cmNlUm9vdCA9ICdzcmMnLFxuICBzdHJpY3QgPSBmYWxzZSxcbiAgc2hvd1BhY2thZ2VzT3JkZXIgPSBmYWxzZSxcbiAgZGlzdCA9IHBhdGgucmVzb2x2ZShjd2QsICdvdXQvcGFja2FnZXMnKSxcbiAgdHNjb25maWcgPSAndHNjb25maWcuanNvbicsXG4gIGVudHJ5LFxuICBzdmcgPSAnY3JlYXRlLXJlYWN0LWFwcCcsXG4gIHRyYW5zZm9ybVBhY2thZ2VKc29uLFxuICB0cmFuc2Zvcm1Db21waWxlckhvc3QsXG4gIHRyYW5zZm9ybUNvbXBpbGVyT3B0aW9ucyxcbiAgZW1pdEN1c3RvbVRyYW5zZm9ybWVycyxcbiAgb25NZXNzYWdlID0gYnVpbGRNZXNzYWdlSGFuZGxlcixcbn06IEJ1aWxkUGFyYW1zKSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBzZXQgZW52XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBpZiAoc3ZnID09PSAnZGVmYXVsdCcpIHtcbiAgICBwcm9jZXNzLmVudi5UU19TVkdfRVhQT1JUID0gJ2RlZmF1bHQnO1xuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHJ1bGVcbiAgLy8gY29sbGVjdCBpbmZvcm1hdGlvbiBiYXNlZCBvbiBkaXJlY3RvcnkgcnVsZXNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGNvbnN0IGludGVybmFsUGFja2FnZXM6IE1hcDxzdHJpbmcsIFBhY2thZ2VJbmZvPiA9IGF3YWl0IHJlYWRQYWNrYWdlcyh7XG4gICAgY3dkLFxuICAgIHNvdXJjZVJvb3QsXG4gICAgZW50cnksXG4gIH0pO1xuICBjb25zdCBleHRlcm5hbFBhY2thZ2VzOiBQYWNrYWdlSnNvbi5EZXBlbmRlbmN5ID0gYXdhaXQgZ2V0Um9vdERlcGVuZGVuY2llcyh7XG4gICAgY3dkLFxuICB9KTtcbiAgY29uc3Qgc2hhcmVkQ29uZmlnOiBQYWNrYWdlSnNvbiA9IGF3YWl0IGdldFNoYXJlZFBhY2thZ2VKc29uKHsgY3dkIH0pO1xuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBlbnRyeVxuICAvLyBjcmVhdGUgYnVpbGQgb3B0aW9ucyBiYXNlZCBvbiBydWxlIG91dHB1dFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgY29uc3QgZGVwZW5kZW5jaWVzTWFwOiBNYXA8c3RyaW5nLCBQYWNrYWdlSnNvbi5EZXBlbmRlbmN5PiA9IG5ldyBNYXA8XG4gICAgc3RyaW5nLFxuICAgIFBhY2thZ2VKc29uLkRlcGVuZGVuY3lcbiAgPigpO1xuXG4gIC8vIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGVhY2ggcGFja2FnZVxuICBmb3IgKGNvbnN0IHBhY2thZ2VOYW1lIG9mIGludGVybmFsUGFja2FnZXMua2V5cygpKSB7XG4gICAgY29uc3QgaW1wb3J0czogUGFja2FnZUpzb24uRGVwZW5kZW5jeSA9IGF3YWl0IGNvbGxlY3REZXBlbmRlbmNpZXMoe1xuICAgICAgLy8gY29sbGVjdCBkZXBlbmRlbmNpZXMgZnJvbSBzb3VyY2VzIG9uIHtjd2R9L3NyYy97cGFja2FnZX1cbiAgICAgIHJvb3REaXI6IHBhdGgucmVzb2x2ZShjd2QsIHNvdXJjZVJvb3QsIHBhY2thZ2VOYW1lKSxcbiAgICAgIGludGVybmFsUGFja2FnZXM6IGludGVybmFsUGFja2FnZXMsXG4gICAgICBleHRlcm5hbFBhY2thZ2VzLFxuICAgICAgc2VsZk5hbWVzOiBuZXcgU2V0PHN0cmluZz4oW3BhY2thZ2VOYW1lXSksXG4gICAgICBjaGVja1VuZGVmaW5lZFBhY2thZ2U6ICdlcnJvcicsXG4gICAgICBmaXhJbXBvcnRQYXRoOiAoeyBpbXBvcnRQYXRoLCBmaWxlUGF0aCB9KSA9PlxuICAgICAgICByZXdyaXRlU3JjUGF0aCh7XG4gICAgICAgICAgcm9vdERpcjogcGF0aC5yZXNvbHZlKGN3ZCwgc291cmNlUm9vdCksXG4gICAgICAgICAgaW1wb3J0UGF0aCxcbiAgICAgICAgICBmaWxlUGF0aCxcbiAgICAgICAgfSksXG4gICAgICAuLi5jb2xsZWN0U2NyaXB0cyxcbiAgICB9KTtcblxuICAgIGRlcGVuZGVuY2llc01hcC5zZXQocGFja2FnZU5hbWUsIGltcG9ydHMpO1xuICB9XG5cbiAgY29uc3QgcGFja2FnZUpzb25NYXA6IE1hcDxzdHJpbmcsIFBhY2thZ2VKc29uPiA9IG5ldyBNYXA8XG4gICAgc3RyaW5nLFxuICAgIFBhY2thZ2VKc29uXG4gID4oKTtcblxuICAvLyBjb21wdXRlIHBhY2thZ2UuanNvbiBjb250ZW50cyBlYWNoIHBhY2thZ2VcbiAgZm9yIChjb25zdCBbcGFja2FnZU5hbWUsIHBhY2thZ2VJbmZvXSBvZiBpbnRlcm5hbFBhY2thZ2VzKSB7XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzOiBQYWNrYWdlSnNvbi5EZXBlbmRlbmN5IHwgdW5kZWZpbmVkID1cbiAgICAgIGRlcGVuZGVuY2llc01hcC5nZXQocGFja2FnZU5hbWUpO1xuXG4gICAgaWYgKCFkZXBlbmRlbmNpZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5kZWZpZW5kIGRlcGVuZGVuY2llcyBvZiAke3BhY2thZ2VOYW1lfWApO1xuICAgIH1cblxuICAgIC8vY29uc3QgcGFja2FnZURpcjogc3RyaW5nID0gcGF0aC5yZXNvbHZlKGN3ZCwgc291cmNlUm9vdCwgcGFja2FnZU5hbWUpO1xuXG4gICAgLy8gY29tcHV0ZSBwYWNrYWdlLmpzb25cbiAgICBjb25zdCBjb21wdXRlZFBhY2thZ2VKc29uOiBQYWNrYWdlSnNvbiA9IGF3YWl0IGNvbXB1dGVQYWNrYWdlSnNvbih7XG4gICAgICBwYWNrYWdlSW5mbyxcbiAgICAgIHNoYXJlZENvbmZpZyxcbiAgICAgIGRlcGVuZGVuY2llcyxcbiAgICB9KTtcblxuICAgIC8vIHRyYW5zZm9ybSBwYWNrYWdlLmpzb24gY29udGVudHMgaWYgdXNlciBkaWQgc2V0IHRoZSB0cmFuc2Zvcm1QYWNrYWdlSnNvbigpIGZ1bmN0aW9uXG4gICAgY29uc3QgcGFja2FnZUpzb246IFBhY2thZ2VKc29uID1cbiAgICAgIHR5cGVvZiB0cmFuc2Zvcm1QYWNrYWdlSnNvbiA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHRyYW5zZm9ybVBhY2thZ2VKc29uKHBhY2thZ2VOYW1lKShjb21wdXRlZFBhY2thZ2VKc29uKVxuICAgICAgICA6IGNvbXB1dGVkUGFja2FnZUpzb247XG5cbiAgICBwYWNrYWdlSnNvbk1hcC5zZXQocGFja2FnZU5hbWUsIHBhY2thZ2VKc29uKTtcbiAgfVxuXG4gIC8vIGdldCBwYWNrYWdlIGJ1aWxkIG9yZGVyXG4gIC8vIGl0IHdpbGwgc29ydCBkZXBlbmRzIG9uIHBhY2thZ2VzIGRlcGVuZGVuY3kgcmVsYXRpb25zaGlwXG4gIGNvbnN0IHBhY2thZ2VzT3JkZXIgPSBhd2FpdCBnZXRQYWNrYWdlc09yZGVyKHtcbiAgICBwYWNrYWdlSnNvbkNvbnRlbnRzOiBBcnJheS5mcm9tKHBhY2thZ2VKc29uTWFwLnZhbHVlcygpKSxcbiAgfSk7XG5cbiAgY29uc3Qgb3JkZXI6IHN0cmluZ1tdID0gcGFja2FnZXNPcmRlci5tYXAoKHsgbmFtZSB9KSA9PiBuYW1lKTtcblxuICBpZiAoc2hvd1BhY2thZ2VzT3JkZXIpIHtcbiAgICBjb25zb2xlLmxvZygncGFja2FnZXMgb3JkZXI6Jywgb3JkZXIuam9pbignLCAnKSk7XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKFxuICAgICAgcGF0aC5qb2luKGRpc3QsICdwYWNrYWdlSnNvbk1hcC5qc29uJyksXG4gICAgICBKU09OLnN0cmluZ2lmeShBcnJheS5mcm9tKHBhY2thZ2VKc29uTWFwLnZhbHVlcygpKSwgbnVsbCwgMiksXG4gICAgKTtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIGBwYWNrYWdlSnNvbiBmaWxlcyBzYXZlZCBpbiBcIiR7cGF0aC5qb2luKGRpc3QsICdwYWNrYWdlSnNvbk1hcC5qc29uJyl9XCJgLFxuICAgICk7XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gcnVuXG4gIC8vIGJ1aWxkIHBhY2thZ2VzXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBjb25zdCBzeW1saW5rRGlyczogc3RyaW5nW10gPSBbXTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIGJ1aWxkIGVhY2ggcGFja2FnZXNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBmb3IgKGNvbnN0IHBhY2thZ2VOYW1lIG9mIG9yZGVyKSB7XG4gICAgY29uc3QgcGFja2FnZUluZm86IFBhY2thZ2VJbmZvIHwgdW5kZWZpbmVkID1cbiAgICAgIGludGVybmFsUGFja2FnZXMuZ2V0KHBhY2thZ2VOYW1lKTtcblxuICAgIGlmICghcGFja2FnZUluZm8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5kZWZpbmVkIHBhY2thZ2VJbmZvIG9mICR7cGFja2FnZU5hbWV9YCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc291cmNlRGlyOiBzdHJpbmcgPSBwYXRoLnJlc29sdmUoY3dkLCBzb3VyY2VSb290LCBwYWNrYWdlTmFtZSk7XG4gICAgY29uc3Qgb3V0RGlyOiBzdHJpbmcgPSBwYXRoLnJlc29sdmUoZGlzdCwgZmxhdFBhY2thZ2VOYW1lKHBhY2thZ2VOYW1lKSk7XG4gICAgY29uc3QgcGFja2FnZUpzb246IFBhY2thZ2VKc29uIHwgdW5kZWZpbmVkID1cbiAgICAgIHBhY2thZ2VKc29uTWFwLmdldChwYWNrYWdlTmFtZSk7XG5cbiAgICBpZiAoIXBhY2thZ2VKc29uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZGVmaW5lZCBwYWNrYWdlanNvbiBjb250ZW50IWApO1xuICAgIH1cblxuICAgIGF3YWl0IG9uTWVzc2FnZSh7XG4gICAgICB0eXBlOiAnYmVnaW4nLFxuICAgICAgcGFja2FnZU5hbWUsXG4gICAgICBzb3VyY2VEaXIsXG4gICAgICBvdXREaXIsXG4gICAgfSk7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBjbGVhblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGF3YWl0IHJpbXJhZihvdXREaXIpO1xuXG4gICAgYXdhaXQgZnMubWtkaXJwKG91dERpcik7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBzeW1saW5rXG4gICAgLy8gdGhpcyBzeW1saW5rIHdpbGwgYmUgcmVmZXJlbmNlIHRvIG5leHQgYnVpbGQgcGFja2FnZXNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBjb25zdCBzeW1saW5rOiBzdHJpbmcgPSBwYXRoLnJlc29sdmUoY3dkLCAnbm9kZV9tb2R1bGVzJywgcGFja2FnZU5hbWUpO1xuXG4gICAgaWYgKGZzLmV4aXN0c1N5bmMoc3ltbGluaykgJiYgZnMubHN0YXRTeW5jKHN5bWxpbmspLmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgIGZzLnVubGlua1N5bmMoc3ltbGluayk7XG4gICAgfVxuXG4gICAgYXdhaXQgZnMubWtkaXJwKHBhdGguZGlybmFtZShzeW1saW5rKSk7XG5cbiAgICBhd2FpdCBmcy5zeW1saW5rKG91dERpciwgc3ltbGluayk7XG5cbiAgICBzeW1saW5rRGlycy5wdXNoKHN5bWxpbmspO1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gdHNjXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgY29uc3QgYnVpbGRUeXBlczogKCdtb2R1bGUnIHwgJ2NvbW1vbmpzJylbXSA9IFtdO1xuXG4gICAgaWYgKHBhY2thZ2VJbmZvLmV4cG9ydHMubW9kdWxlKSBidWlsZFR5cGVzLnB1c2goJ21vZHVsZScpO1xuICAgIGlmIChwYWNrYWdlSW5mby5leHBvcnRzLmNvbW1vbmpzKSBidWlsZFR5cGVzLnB1c2goJ2NvbW1vbmpzJyk7XG5cbiAgICBmb3IgKGNvbnN0IGJ1aWxkVHlwZSBvZiBidWlsZFR5cGVzKSB7XG4gICAgICBjb25zdCBpc01haW5CdWlsZCA9IGJ1aWxkVHlwZSA9PT0gcGFja2FnZUluZm8uZXhwb3J0cy5tYWluO1xuXG4gICAgICAvLyByZWFkIGNvbXBpbGVyT3B0aW9ucyBmcm9tIHtjd2R9L3RzY29uZmlnLmpzb25cbiAgICAgIGNvbnN0IHVzZXJDb21waWxlck9wdGlvbnM6IHRzLkNvbXBpbGVyT3B0aW9ucyA9IGdldENvbXBpbGVyT3B0aW9ucyh7XG4gICAgICAgIHNlYXJjaFBhdGg6IGN3ZCxcbiAgICAgICAgY29uZmlnTmFtZTogdHNjb25maWcsXG4gICAgICAgIHBhY2thZ2VJbmZvLFxuICAgICAgICBidWlsZFR5cGUsXG4gICAgICAgIGRlY2xhcmF0aW9uOiBpc01haW5CdWlsZCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBjb21wdXRlIHBhY2thZ2UuanNvbiB3aXRoIGFkZCBzb21lIGJ1aWxkIGluZm9ybWF0aW9uXG4gICAgICBjb25zdCBjb21wdXRlZENvbXBpbGVyT3B0aW9uczogdHMuQ29tcGlsZXJPcHRpb25zID0ge1xuICAgICAgICAuLi51c2VyQ29tcGlsZXJPcHRpb25zLFxuXG4gICAgICAgIGJhc2VVcmw6IHNvdXJjZURpcixcbiAgICAgICAgcGF0aHM6IHtcbiAgICAgICAgICAuLi51c2VyQ29tcGlsZXJPcHRpb25zLnBhdGhzLFxuICAgICAgICAgIFtwYWNrYWdlTmFtZV06IFsnLiddLFxuICAgICAgICAgIFtwYWNrYWdlTmFtZSArICcvKiddOiBbJy4vKiddLFxuICAgICAgICB9LFxuXG4gICAgICAgIHJvb3REaXI6IHNvdXJjZURpcixcbiAgICAgICAgb3V0RGlyOiBpc01haW5CdWlsZCA/IG91dERpciA6IHBhdGguam9pbihvdXREaXIsIGBfJHtidWlsZFR5cGV9YCksXG4gICAgICAgIGluY3JlbWVudGFsOiB0cnVlLFxuICAgICAgICB0c0J1aWxkSW5mb0ZpbGU6IHBhdGguam9pbihcbiAgICAgICAgICBkaXN0LFxuICAgICAgICAgIGZsYXRQYWNrYWdlTmFtZShwYWNrYWdlTmFtZSkgKyAnLnRzYnVpbGRpbmZvJyxcbiAgICAgICAgKSxcbiAgICAgIH07XG5cbiAgICAgIC8vIHRyYW5zZm9ybSBjb21waWxlck9wdGlvbnMgaWYgdXNlciBzZXQgdGhlIHRyYW5zZm9ybUNvbXBpbGVyT3B0aW9ucygpIGZ1bmN0aW9uXG4gICAgICBjb25zdCBjb21waWxlck9wdGlvbnM6IHRzLkNvbXBpbGVyT3B0aW9ucyA9XG4gICAgICAgIHR5cGVvZiB0cmFuc2Zvcm1Db21waWxlck9wdGlvbnMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICA/IHRyYW5zZm9ybUNvbXBpbGVyT3B0aW9ucyhwYWNrYWdlTmFtZSkoY29tcHV0ZWRDb21waWxlck9wdGlvbnMpXG4gICAgICAgICAgOiBjb21wdXRlZENvbXBpbGVyT3B0aW9ucztcblxuICAgICAgLy8gY3JlYXRlIGNvbXBpbGVySG9zdFxuICAgICAgY29uc3QgZXh0ZW5kZWRIb3N0OiB0cy5Db21waWxlckhvc3QgPVxuICAgICAgICBjcmVhdGVFeHRlbmRlZENvbXBpbGVySG9zdChjb21waWxlck9wdGlvbnMpO1xuXG4gICAgICBjb25zdCBwYXRoUmV3cml0ZUhvc3Q6IHRzLkNvbXBpbGVySG9zdCA9XG4gICAgICAgIGNyZWF0ZUltcG9ydFBhdGhSZXdyaXRlQ29tcGlsZXJIb3N0KHtcbiAgICAgICAgICBzcmM6IHBhdGgucmVzb2x2ZShjd2QsIHNvdXJjZVJvb3QpLFxuICAgICAgICAgIHJvb3REaXI6IHNvdXJjZURpcixcbiAgICAgICAgfSkoY29tcGlsZXJPcHRpb25zLCB1bmRlZmluZWQsIGV4dGVuZGVkSG9zdCk7XG5cbiAgICAgIC8vIHRyYW5zZm9ybSBjb21waWxlckhvc3QgaWYgdXNlciBzZXQgdGhlIHRyYW5zZm9ybUNvbXBpbGVySG9zdCgpIGZ1bmN0aW9uXG4gICAgICBjb25zdCBob3N0OiB0cy5Db21waWxlckhvc3QgPVxuICAgICAgICB0eXBlb2YgdHJhbnNmb3JtQ29tcGlsZXJIb3N0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgPyB0cmFuc2Zvcm1Db21waWxlckhvc3QocGFja2FnZU5hbWUpKGNvbXBpbGVyT3B0aW9ucywgcGF0aFJld3JpdGVIb3N0KVxuICAgICAgICAgIDogcGF0aFJld3JpdGVIb3N0O1xuXG4gICAgICBjb25zdCBmaWxlczogc3RyaW5nW10gPSBob3N0LnJlYWREaXJlY3RvcnkhKFxuICAgICAgICBzb3VyY2VEaXIsXG4gICAgICAgIC4uLnJlYWREaXJlY3RvcnlQYXR0ZXJucyxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHByb2dyYW06IHRzLlByb2dyYW0gPSB0cy5jcmVhdGVQcm9ncmFtKFxuICAgICAgICBmaWxlcyxcbiAgICAgICAgY29tcGlsZXJPcHRpb25zLFxuICAgICAgICBob3N0LFxuICAgICAgKTtcblxuICAgICAgY29uc3QgY3VzdG9tVHJhbnNmb3JtZXJzID1cbiAgICAgICAgdHlwZW9mIGVtaXRDdXN0b21UcmFuc2Zvcm1lcnMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICA/IGVtaXRDdXN0b21UcmFuc2Zvcm1lcnMocGFja2FnZU5hbWUpKCkgPz8ge31cbiAgICAgICAgICA6IHt9O1xuXG4gICAgICBjdXN0b21UcmFuc2Zvcm1lcnMuYWZ0ZXIgPSBbXG4gICAgICAgIC4uLihjdXN0b21UcmFuc2Zvcm1lcnMuYWZ0ZXIgPz8gW10pLFxuICAgICAgICBidW5kbGVJbXBvcnRSZXdyaXRlKHt9KSxcbiAgICAgIF07XG5cbiAgICAgIC8vIPCflKUgY29tcGlsZSEhISEhISEhIVxuICAgICAgY29uc3QgZW1pdFJlc3VsdDogdHMuRW1pdFJlc3VsdCA9IHByb2dyYW0uZW1pdChcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBjdXN0b21UcmFuc2Zvcm1lcnMsXG4gICAgICApO1xuXG4gICAgICBjb25zdCBkaWFnbm9zdGljczogdHMuRGlhZ25vc3RpY1tdID0gdHNcbiAgICAgICAgLmdldFByZUVtaXREaWFnbm9zdGljcyhwcm9ncmFtKVxuICAgICAgICAuY29uY2F0KGVtaXRSZXN1bHQuZGlhZ25vc3RpY3MpO1xuXG4gICAgICBhd2FpdCBvbk1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiAndHNjJyxcbiAgICAgICAgcGFja2FnZU5hbWUsXG4gICAgICAgIGNvbXBpbGVyT3B0aW9ucyxcbiAgICAgICAgZGlhZ25vc3RpY3MsXG4gICAgICB9KTtcblxuICAgICAgaWYgKChzdHJpY3QgJiYgZGlhZ25vc3RpY3MubGVuZ3RoID4gMCkgfHwgZW1pdFJlc3VsdC5lbWl0U2tpcHBlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJ1aWxkIFwiJHtwYWNrYWdlTmFtZX1cIiBpcyBmYWlsZWRgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBjb3B5IHN0YXRpYyBmaWxlc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGF3YWl0IGZzLmNvcHkocGF0aC5yZXNvbHZlKGN3ZCwgc291cmNlUm9vdCwgcGFja2FnZU5hbWUpLCBvdXREaXIsIHtcbiAgICAgIGZpbHRlcjogZnNDb3B5RmlsdGVyLFxuICAgIH0pO1xuXG4gICAgcGFja2FnZUpzb24uZXhwb3J0cyA9IGF3YWl0IGdldEV4cG9ydHMocGFja2FnZUluZm8uZXhwb3J0cywgb3V0RGlyKTtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGNyZWF0ZSBwYWNrYWdlLmpzb25cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBhd2FpdCBmcy53cml0ZUpzb24ocGF0aC5yZXNvbHZlKG91dERpciwgJ3BhY2thZ2UuanNvbicpLCBwYWNrYWdlSnNvbiwge1xuICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgIHNwYWNlczogMixcbiAgICB9KTtcblxuICAgIGF3YWl0IG9uTWVzc2FnZSh7XG4gICAgICB0eXBlOiAncGFja2FnZS1qc29uJyxcbiAgICAgIHBhY2thZ2VOYW1lLFxuICAgICAgcGFja2FnZUpzb24sXG4gICAgfSk7XG5cbiAgICBhd2FpdCBvbk1lc3NhZ2Uoe1xuICAgICAgdHlwZTogJ3N1Y2Nlc3MnLFxuICAgICAgcGFja2FnZUpzb24sXG4gICAgICBwYWNrYWdlTmFtZSxcbiAgICAgIHNvdXJjZURpcixcbiAgICAgIG91dERpcixcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGNsZWFuIHN5bWxpbmtzIG9uIG5vZGVfbW9kdWxlc1xuICBmb3IgKGNvbnN0IHN5bWxpbmsgb2Ygc3ltbGlua0RpcnMpIHtcbiAgICBmcy51bmxpbmtTeW5jKHN5bWxpbmspO1xuICB9XG59XG4iXX0=