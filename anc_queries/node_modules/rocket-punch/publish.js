import { flatPackageName } from '@ssen/flat-package-name';
import { getPublishOptions, selectPublishOptions, } from '@ssen/publish-packages';
import path from 'path';
import process from 'process';
import { readPackages } from './entry/readPackages';
import { publishMessageHandler } from './message-handlers/publish';
export async function publish({ cwd = process.cwd(), sourceRoot = 'src', dist = path.join(cwd, 'out/packages'), skipSelection = false, tag, access, entry, registry, onMessage = publishMessageHandler, }) {
    const packages = await readPackages({
        cwd,
        sourceRoot,
        entry,
    });
    const publishOptions = await getPublishOptions({
        packages,
        outDir: dist,
        tag,
        registry,
    });
    const selectedPublishOptions = await selectPublishOptions({
        publishOptions,
        skipSelection,
    });
    for (const publishOption of selectedPublishOptions) {
        const packageInfo = packages.get(publishOption.name);
        if (!packageInfo) {
            throw new Error(`Undefined packageInfo "${publishOption.name}"`);
        }
        const p = [`--tag ${tag || publishOption.tag}`];
        if (access) {
            p.push(`--access ${access}`);
        }
        else if (packageInfo.access) {
            p.push(`--access ${packageInfo.access}`);
        }
        if (registry) {
            p.push(`--registry "${registry}"`);
        }
        else if (packageInfo.registry) {
            p.push(`--registry "${packageInfo.registry}"`);
        }
        const command = process.platform === 'win32'
            ? `cd "${path.join(dist, flatPackageName(publishOption.name))}" && npm publish ${p.join(' ')}`
            : `cd "${path.join(dist, flatPackageName(publishOption.name))}"; npm publish ${p.join(' ')};`;
        await onMessage({
            type: 'exec',
            command,
            publishOption,
        });
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHVibGlzaC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yb2NrZXQtcHVuY2gvcHVibGlzaC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDMUQsT0FBTyxFQUVMLGlCQUFpQixFQUNqQixvQkFBb0IsR0FDckIsTUFBTSx3QkFBd0IsQ0FBQztBQUNoQyxPQUFPLElBQUksTUFBTSxNQUFNLENBQUM7QUFDeEIsT0FBTyxPQUFPLE1BQU0sU0FBUyxDQUFDO0FBQzlCLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUNwRCxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUluRSxNQUFNLENBQUMsS0FBSyxVQUFVLE9BQU8sQ0FBQyxFQUM1QixHQUFHLEdBQUcsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUNuQixVQUFVLEdBQUcsS0FBSyxFQUNsQixJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsY0FBYyxDQUFDLEVBQ3JDLGFBQWEsR0FBRyxLQUFLLEVBQ3JCLEdBQUcsRUFDSCxNQUFNLEVBQ04sS0FBSyxFQUNMLFFBQVEsRUFDUixTQUFTLEdBQUcscUJBQXFCLEdBQ25CO0lBQ2QsTUFBTSxRQUFRLEdBQTZCLE1BQU0sWUFBWSxDQUFDO1FBQzVELEdBQUc7UUFDSCxVQUFVO1FBQ1YsS0FBSztLQUNOLENBQUMsQ0FBQztJQUVILE1BQU0sY0FBYyxHQUErQixNQUFNLGlCQUFpQixDQUFDO1FBQ3pFLFFBQVE7UUFDUixNQUFNLEVBQUUsSUFBSTtRQUNaLEdBQUc7UUFDSCxRQUFRO0tBQ1QsQ0FBQyxDQUFDO0lBRUgsTUFBTSxzQkFBc0IsR0FBNkIsTUFBTSxvQkFBb0IsQ0FDakY7UUFDRSxjQUFjO1FBQ2QsYUFBYTtLQUNkLENBQ0YsQ0FBQztJQUVGLEtBQUssTUFBTSxhQUFhLElBQUksc0JBQXNCLEVBQUU7UUFDbEQsTUFBTSxXQUFXLEdBQTRCLFFBQVEsQ0FBQyxHQUFHLENBQ3ZELGFBQWEsQ0FBQyxJQUFJLENBQ25CLENBQUM7UUFFRixJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ2hCLE1BQU0sSUFBSSxLQUFLLENBQUMsMEJBQTBCLGFBQWEsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO1NBQ2xFO1FBRUQsTUFBTSxDQUFDLEdBQWEsQ0FBQyxTQUFTLEdBQUcsSUFBSSxhQUFhLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztRQUUxRCxJQUFJLE1BQU0sRUFBRTtZQUNWLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxNQUFNLEVBQUUsQ0FBQyxDQUFDO1NBQzlCO2FBQU0sSUFBSSxXQUFXLENBQUMsTUFBTSxFQUFFO1lBQzdCLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxXQUFXLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztTQUMxQztRQUVELElBQUksUUFBUSxFQUFFO1lBQ1osQ0FBQyxDQUFDLElBQUksQ0FBQyxlQUFlLFFBQVEsR0FBRyxDQUFDLENBQUM7U0FDcEM7YUFBTSxJQUFJLFdBQVcsQ0FBQyxRQUFRLEVBQUU7WUFDL0IsQ0FBQyxDQUFDLElBQUksQ0FBQyxlQUFlLFdBQVcsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDO1NBQ2hEO1FBRUQsTUFBTSxPQUFPLEdBQ1gsT0FBTyxDQUFDLFFBQVEsS0FBSyxPQUFPO1lBQzFCLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQ2QsSUFBSSxFQUNKLGVBQWUsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQ3BDLG9CQUFvQixDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ3BDLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQ2QsSUFBSSxFQUNKLGVBQWUsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQ3BDLGtCQUFrQixDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7UUFFeEMsTUFBTSxTQUFTLENBQUM7WUFDZCxJQUFJLEVBQUUsTUFBTTtZQUNaLE9BQU87WUFDUCxhQUFhO1NBQ2QsQ0FBQyxDQUFDO0tBQ0o7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZmxhdFBhY2thZ2VOYW1lIH0gZnJvbSAnQHNzZW4vZmxhdC1wYWNrYWdlLW5hbWUnO1xuaW1wb3J0IHtcbiAgQXZhaWxhYmxlUHVibGlzaE9wdGlvbixcbiAgZ2V0UHVibGlzaE9wdGlvbnMsXG4gIHNlbGVjdFB1Ymxpc2hPcHRpb25zLFxufSBmcm9tICdAc3Nlbi9wdWJsaXNoLXBhY2thZ2VzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHByb2Nlc3MgZnJvbSAncHJvY2Vzcyc7XG5pbXBvcnQgeyByZWFkUGFja2FnZXMgfSBmcm9tICcuL2VudHJ5L3JlYWRQYWNrYWdlcyc7XG5pbXBvcnQgeyBwdWJsaXNoTWVzc2FnZUhhbmRsZXIgfSBmcm9tICcuL21lc3NhZ2UtaGFuZGxlcnMvcHVibGlzaCc7XG5pbXBvcnQgeyBQdWJsaXNoUGFyYW1zIH0gZnJvbSAnLi9wYXJhbXMnO1xuaW1wb3J0IHsgUGFja2FnZUluZm8sIFB1Ymxpc2hPcHRpb24gfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHB1Ymxpc2goe1xuICBjd2QgPSBwcm9jZXNzLmN3ZCgpLFxuICBzb3VyY2VSb290ID0gJ3NyYycsXG4gIGRpc3QgPSBwYXRoLmpvaW4oY3dkLCAnb3V0L3BhY2thZ2VzJyksXG4gIHNraXBTZWxlY3Rpb24gPSBmYWxzZSxcbiAgdGFnLFxuICBhY2Nlc3MsXG4gIGVudHJ5LFxuICByZWdpc3RyeSxcbiAgb25NZXNzYWdlID0gcHVibGlzaE1lc3NhZ2VIYW5kbGVyLFxufTogUHVibGlzaFBhcmFtcykge1xuICBjb25zdCBwYWNrYWdlczogTWFwPHN0cmluZywgUGFja2FnZUluZm8+ID0gYXdhaXQgcmVhZFBhY2thZ2VzKHtcbiAgICBjd2QsXG4gICAgc291cmNlUm9vdCxcbiAgICBlbnRyeSxcbiAgfSk7XG5cbiAgY29uc3QgcHVibGlzaE9wdGlvbnM6IE1hcDxzdHJpbmcsIFB1Ymxpc2hPcHRpb24+ID0gYXdhaXQgZ2V0UHVibGlzaE9wdGlvbnMoe1xuICAgIHBhY2thZ2VzLFxuICAgIG91dERpcjogZGlzdCxcbiAgICB0YWcsXG4gICAgcmVnaXN0cnksXG4gIH0pO1xuXG4gIGNvbnN0IHNlbGVjdGVkUHVibGlzaE9wdGlvbnM6IEF2YWlsYWJsZVB1Ymxpc2hPcHRpb25bXSA9IGF3YWl0IHNlbGVjdFB1Ymxpc2hPcHRpb25zKFxuICAgIHtcbiAgICAgIHB1Ymxpc2hPcHRpb25zLFxuICAgICAgc2tpcFNlbGVjdGlvbixcbiAgICB9LFxuICApO1xuXG4gIGZvciAoY29uc3QgcHVibGlzaE9wdGlvbiBvZiBzZWxlY3RlZFB1Ymxpc2hPcHRpb25zKSB7XG4gICAgY29uc3QgcGFja2FnZUluZm86IFBhY2thZ2VJbmZvIHwgdW5kZWZpbmVkID0gcGFja2FnZXMuZ2V0KFxuICAgICAgcHVibGlzaE9wdGlvbi5uYW1lLFxuICAgICk7XG5cbiAgICBpZiAoIXBhY2thZ2VJbmZvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZGVmaW5lZCBwYWNrYWdlSW5mbyBcIiR7cHVibGlzaE9wdGlvbi5uYW1lfVwiYCk7XG4gICAgfVxuXG4gICAgY29uc3QgcDogc3RyaW5nW10gPSBbYC0tdGFnICR7dGFnIHx8IHB1Ymxpc2hPcHRpb24udGFnfWBdO1xuXG4gICAgaWYgKGFjY2Vzcykge1xuICAgICAgcC5wdXNoKGAtLWFjY2VzcyAke2FjY2Vzc31gKTtcbiAgICB9IGVsc2UgaWYgKHBhY2thZ2VJbmZvLmFjY2Vzcykge1xuICAgICAgcC5wdXNoKGAtLWFjY2VzcyAke3BhY2thZ2VJbmZvLmFjY2Vzc31gKTtcbiAgICB9XG5cbiAgICBpZiAocmVnaXN0cnkpIHtcbiAgICAgIHAucHVzaChgLS1yZWdpc3RyeSBcIiR7cmVnaXN0cnl9XCJgKTtcbiAgICB9IGVsc2UgaWYgKHBhY2thZ2VJbmZvLnJlZ2lzdHJ5KSB7XG4gICAgICBwLnB1c2goYC0tcmVnaXN0cnkgXCIke3BhY2thZ2VJbmZvLnJlZ2lzdHJ5fVwiYCk7XG4gICAgfVxuXG4gICAgY29uc3QgY29tbWFuZDogc3RyaW5nID1cbiAgICAgIHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMidcbiAgICAgICAgPyBgY2QgXCIke3BhdGguam9pbihcbiAgICAgICAgICAgIGRpc3QsXG4gICAgICAgICAgICBmbGF0UGFja2FnZU5hbWUocHVibGlzaE9wdGlvbi5uYW1lKSxcbiAgICAgICAgICApfVwiICYmIG5wbSBwdWJsaXNoICR7cC5qb2luKCcgJyl9YFxuICAgICAgICA6IGBjZCBcIiR7cGF0aC5qb2luKFxuICAgICAgICAgICAgZGlzdCxcbiAgICAgICAgICAgIGZsYXRQYWNrYWdlTmFtZShwdWJsaXNoT3B0aW9uLm5hbWUpLFxuICAgICAgICAgICl9XCI7IG5wbSBwdWJsaXNoICR7cC5qb2luKCcgJyl9O2A7XG5cbiAgICBhd2FpdCBvbk1lc3NhZ2Uoe1xuICAgICAgdHlwZTogJ2V4ZWMnLFxuICAgICAgY29tbWFuZCxcbiAgICAgIHB1Ymxpc2hPcHRpb24sXG4gICAgfSk7XG4gIH1cbn1cbiJdfQ==